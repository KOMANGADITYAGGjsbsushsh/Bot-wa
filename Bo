
import pino from 'pino';
import fs from 'fs';
import { execSync, exec } from 'child_process';
import path, { dirname } from 'path';
import yts from 'yt-search';
import axios from 'axios';
import { fileURLToPath } from 'url';
import ffmpeg from 'fluent-ffmpeg';
import { fileTypeFromBuffer } from 'file-type';
import translate from '@vitalets/google-translate-api';
import fetch from 'node-fetch';
import sharp from 'sharp';
import * as cheerio from 'cheerio';
import qrcode from 'qrcode-terminal';
import pkg from 'wa-sticker-formatter';
const { Sticker, StickerTypes } = pkg;
import {
    useMultiFileAuthState,
    makeWASocket,
    downloadMediaMessage,
    DisconnectReason,
    fetchLatestBaileysVersion
} from '@whiskeysockets/baileys';
import * as Jimp from 'jimp';
import { promisify } from 'util';
const execAsync = promisify(exec);

// ==================== REACTION MESSAGE SYSTEM ====================
class ReactionSystem {
    constructor() {
        this.reactions = {
            'loading': 'üïí',
            'success': '‚úÖ',
            'error': '‚ùå',
            'warning': '‚ö†Ô∏è',
            'info': '‚ÑπÔ∏è',
            'processing': '‚öôÔ∏è',
            'downloading': '‚¨áÔ∏è',
            'uploading': '‚¨ÜÔ∏è',
            'searching': 'üîç'
        };
        
        this.activeReactions = new Map();
    }

    async sendReaction(sock, jid, key, reactionType = 'loading') {
        try {
            const reaction = this.reactions[reactionType] || 'üîÑ';
            await sock.sendMessage(jid, {
                react: {
                    text: reaction,
                    key: key
                }
            });
            
            const reactionId = `${jid}_${key.id}`;
            this.activeReactions.set(reactionId, {
                jid: jid,
                key: key,
                reaction: reaction,
                timestamp: Date.now()
            });
            
            return reactionId;
        } catch (error) {
            console.error('Error sending reaction:', error);
            return null;
        }
    }

    async updateReaction(sock, jid, key, newReactionType) {
        try {
            const reaction = this.reactions[newReactionType] || 'üîÑ';
            await sock.sendMessage(jid, {
                react: {
                    text: reaction,
                    key: key
                }
            });
            
            const reactionId = `${jid}_${key.id}`;
            this.activeReactions.set(reactionId, {
                jid: jid,
                key: key,
                reaction: reaction,
                timestamp: Date.now(),
                updated: true
            });
            
            return true;
        } catch (error) {
            console.error('Error updating reaction:', error);
            return false;
        }
    }

    async removeReaction(sock, jid, key) {
        try {
            await sock.sendMessage(jid, {
                react: {
                    text: '',
                    key: key
                }
            });
            
            const reactionId = `${jid}_${key.id}`;
            this.activeReactions.delete(reactionId);
            
            return true;
        } catch (error) {
            console.error('Error removing reaction:', error);
            return false;
        }
    }

    async processWithReaction(sock, jid, key, processFunction, processName = 'Task') {
        const startTime = Date.now();
        
        try {
            await this.sendReaction(sock, jid, key, 'loading');
            console.log(`üîÑ [${processName}] Started processing...`);
            
            const result = await processFunction();
            
            const endTime = Date.now();
            const duration = endTime - startTime;
            
            await this.updateReaction(sock, jid, key, 'success');
            console.log(`‚úÖ [${processName}] Completed in ${duration}ms`);
            
            return {
                success: true,
                result: result,
                duration: duration
            };
            
        } catch (error) {
            const endTime = Date.now();
            const duration = endTime - startTime;
            
            await this.updateReaction(sock, jid, key, 'error');
            console.error(`‚ùå [${processName}] Failed after ${duration}ms:`, error.message);
            
            return {
                success: false,
                error: error.message,
                duration: duration
            };
        }
    }

    async withLoadingReaction(sock, jid, key, duration = 5000) {
        await this.sendReaction(sock, jid, key, 'loading');
        
        setTimeout(async () => {
            try {
                await this.removeReaction(sock, jid, key);
            } catch (error) {
                console.error('Error auto-removing reaction:', error);
            }
        }, duration);
        
        return {
            update: async (newReactionType) => {
                return await this.updateReaction(sock, jid, key, newReactionType);
            },
            remove: async () => {
                return await this.removeReaction(sock, jid, key);
            },
            success: async () => {
                return await this.updateReaction(sock, jid, key, 'success');
            },
            error: async () => {
                return await this.updateReaction(sock, jid, key, 'error');
            }
        };
    }

    cleanupOldReactions(maxAge = 3600000) {
        const now = Date.now();
        for (const [reactionId, data] of this.activeReactions.entries()) {
            if (now - data.timestamp > maxAge) {
                this.activeReactions.delete(reactionId);
            }
        }
    }
}

const reactionSystem = new ReactionSystem();

// ==================== KONFIGURASI ====================
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const tempDir = path.join(__dirname, 'temp');
try {
    if (!fs.existsSync(tempDir)) {
        fs.mkdirSync(tempDir, { recursive: true });
        console.log(`üìÅ Created temp directory: ${tempDir}`);
    }
} catch (error) {
    console.error('‚ùå Failed to create temp directory:', error);
}

const OPENROUTER_API_KEY = process.env.OPENROUTER_API_KEY || '';
const OPENWEATHER_API_KEY = process.env.OPENWEATHER_API_KEY || '';
const NEWS_API_KEY = process.env.NEWS_API_KEY || '';
const STICKER_API_KEY = process.env.STICKER_API_KEY || '';
const GEMINI_API_KEY = process.env.GEMINI_API_KEY || '';

// ==================== STORAGE & DATABASE ====================
const userDatabase = new Map();
let userCounter = 0;
const viewOnceMedia = new Map();
const userCooldowns = new Map();
const groupDatabase = new Map();
const geminiConversations = new Map();
const chatbotDatabase = new Map();
const userWarnings = new Map();
const antiSpam = new Map();
const groupSettings = new Map();
const userProfiles = new Map();
const gameSessions = new Map();
const quizSessions = new Map();
const reminderSystem = new Map();
const autoReplySystem = new Map();
const levelSystem = new Map();
const marriageSystem = new Map();
const inventorySystem = new Map();

// ==================== SIPUTZX API CONFIG ====================
const SIPUTZX_API = 'https://api.siputzx.my.id/api';

// ==================== AI SYSTEM (SIPUTZX) ====================
class SiputzxAISystem {
    constructor() {
        this.conversations = new Map();
        this.MAX_HISTORY = 5;
    }

    async chat(message, userId) {
        try {
            if (!this.conversations.has(userId)) {
                this.conversations.set(userId, []);
            }
            
            const history = this.conversations.get(userId);
            history.push({ role: "user", content: message });
            
            if (history.length > this.MAX_HISTORY * 2) {
                history.splice(0, 2);
            }
            
            const response = await axios.get(`${SIPUTZX_API}/ai/gpt3`, {
                params: {
                    prompt: message
                },
                timeout: 30000
            });
            
            if (response.data?.status) {
                const aiResponse = response.data.data;
                history.push({ role: "assistant", content: aiResponse });
                
                return {
                    success: true,
                    response: aiResponse,
                    timestamp: response.data.timestamp || new Date().toISOString()
                };
            } else {
                throw new Error('API response error');
            }
        } catch (error) {
            console.error('Siputzx AI Error:', error);
            return {
                success: false,
                response: "Maaf, AI sedang sibuk. Coba lagi nanti.",
                error: error.message
            };
        }
    }

    clearHistory(userId) {
        this.conversations.delete(userId);
        return true;
    }
}

const siputzxAI = new SiputzxAISystem();

// ==================== STICKER MAKER API SYSTEM ====================
class StickerAPISystem {
    constructor() {
        this.apis = [
            {
                name: 'Siputzx',
                url: 'https://api.siputzx.my.id/api/sticker/text',
                method: 'GET',
                params: (text, style) => ({
                    text: text,
                    style: style || 'default'
                })
            },
            {
                name: 'Stickerly',
                url: 'https://api.stickerly.io/api/v1/sticker/create',
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                data: (text, style) => ({
                    text: text,
                    style: style || 'standard',
                    format: 'webp'
                })
            },
            {
                name: 'Canva Sticker',
                url: 'https://api.canva.com/v1/stickers',
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${STICKER_API_KEY}`,
                    'Content-Type': 'application/json'
                },
                data: (text, style) => ({
                    text: text,
                    template: style || 'default',
                    output_format: 'webp'
                })
            }
        ];
    }

    async createSticker(text, style = 'default') {
        if (!text || text.trim().length === 0) {
            throw new Error('Text tidak boleh kosong');
        }

        // Coba API satu per satu
        for (const api of this.apis) {
            try {
                console.log(`üîÑ Mencoba API ${api.name} untuk membuat sticker...`);
                
                let response;
                if (api.method === 'GET') {
                    const params = api.params(text, style);
                    response = await axios.get(api.url, {
                        params: params,
                        responseType: 'arraybuffer',
                        timeout: 30000,
                        headers: api.headers || {}
                    });
                } else {
                    const data = api.data(text, style);
                    response = await axios.post(api.url, data, {
                        responseType: 'arraybuffer',
                        timeout: 30000,
                        headers: api.headers || {}
                    });
                }

                if (response.data && response.data.byteLength > 0) {
                    const stickerBuffer = Buffer.from(response.data);
                    
                    // Validasi bahwa ini benar-benar gambar/webp
                    const fileType = await fileTypeFromBuffer(stickerBuffer);
                    if (!fileType || !['webp', 'png', 'jpg', 'jpeg'].includes(fileType.ext)) {
                        throw new Error('Response bukan gambar yang valid');
                    }

                    console.log(`‚úÖ Sticker berhasil dibuat dengan API ${api.name}`);
                    return {
                        buffer: stickerBuffer,
                        api: api.name,
                        size: stickerBuffer.length
                    };
                }
            } catch (error) {
                console.warn(`‚ö†Ô∏è API ${api.name} gagal:`, error.message);
                continue;
            }
        }

        // Fallback: buat sticker lokal jika semua API gagal
        console.log('üîß Semua API gagal, membuat sticker lokal...');
        return await this.createLocalSticker(text, style);
    }

    async createLocalSticker(text, style = 'default') {
        try {
            const width = 512;
            const height = 512;
            
            // Tentukan warna berdasarkan style
            let backgroundColor = '#FFFFFF';
            let textColor = '#000000';
            let fontSize = 40;
            let fontStyle = 'Arial';
            
            switch(style.toLowerCase()) {
                case 'rainbow':
                    backgroundColor = 'linear-gradient(45deg, #FF0000, #FF7F00, #FFFF00, #00FF00, #0000FF, #4B0082, #8B00FF)';
                    textColor = '#FFFFFF';
                    fontSize = 45;
                    break;
                case 'bold':
                    backgroundColor = '#000000';
                    textColor = '#FFFFFF';
                    fontSize = 48;
                    fontStyle = 'Arial-Bold';
                    break;
                case 'shadow':
                    backgroundColor = '#2C3E50';
                    textColor = '#ECF0F1';
                    fontSize = 42;
                    break;
                case 'outline':
                    backgroundColor = '#34495E';
                    textColor = '#1ABC9C';
                    fontSize = 44;
                    break;
                case 'funny':
                    backgroundColor = '#FFD700';
                    textColor = '#FF4500';
                    fontSize = 38;
                    fontStyle = 'Comic-Sans-MS';
                    break;
                default:
                    backgroundColor = '#3498DB';
                    textColor = '#FFFFFF';
                    fontSize = 40;
            }

            const svgContent = `
                <svg width="${width}" height="${height}" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                        <linearGradient id="rainbow" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#FF0000" />
                            <stop offset="16.6%" style="stop-color:#FF7F00" />
                            <stop offset="33.3%" style="stop-color:#FFFF00" />
                            <stop offset="50%" style="stop-color:#00FF00" />
                            <stop offset="66.6%" style="stop-color:#0000FF" />
                            <stop offset="83.3%" style="stop-color:#4B0082" />
                            <stop offset="100%" style="stop-color:#8B00FF" />
                        </linearGradient>
                    </defs>
                    <rect width="100%" height="100%" fill="${backgroundColor.startsWith('linear-gradient') ? 'url(#rainbow)' : backgroundColor}" rx="20" ry="20"/>
                    <text x="50%" y="50%" font-family="${fontStyle}" font-size="${fontSize}" 
                          text-anchor="middle" dominant-baseline="middle" fill="${textColor}" 
                          ${style === 'shadow' ? 'filter="url(#shadow)"' : ''}
                          ${style === 'outline' ? 'stroke="#000000" stroke-width="2"' : ''}>
                        ${this.escapeHtml(text)}
                    </text>
                    ${style === 'shadow' ? `
                    <defs>
                        <filter id="shadow" x="-20%" y="-20%" width="140%" height="140%">
                            <feDropShadow dx="4" dy="4" stdDeviation="3" flood-color="#000000" flood-opacity="0.7"/>
                        </filter>
                    </defs>
                    ` : ''}
                </svg>
            `;

            const svgBuffer = Buffer.from(svgContent);
            
            const webpBuffer = await sharp(svgBuffer)
                .resize(width, height)
                .webp({ 
                    quality: 90,
                    lossless: false,
                    effort: 6
                })
                .toBuffer();
            
            return {
                buffer: webpBuffer,
                api: 'local',
                size: webpBuffer.length
            };
        } catch (error) {
            console.error('Error creating local sticker:', error);
            throw new Error(`Gagal membuat sticker lokal: ${error.message}`);
        }
    }

    escapeHtml(text) {
        return text
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#039;');
    }

    async createStickerFromImage(imageBuffer, options = {}) {
        try {
            const {
                author = 'violation bot',
                pack = 'Sticker Pack',
                categories = ['‚ù§Ô∏è', 'üëç', 'üòä'],
                quality = 90
            } = options;

            const sticker = new Sticker(imageBuffer, {
                pack: pack,
                author: author,
                categories: categories,
                quality: quality,
                type: StickerTypes.FULL
            });

            return await sticker.toBuffer();
        } catch (error) {
            console.error('Error creating sticker from image:', error);
            
            // Fallback dengan sharp
            return await sharp(imageBuffer)
                .resize(512, 512, {
                    fit: 'contain',
                    background: { r: 0, g: 0, b: 0, alpha: 0 }
                })
                .webp({
                    quality: 85,
                    lossless: false
                })
                .toBuffer();
        }
    }
}

const stickerAPI = new StickerAPISystem();

// ==================== STICKER MAKER (SIPUTZX) ====================
async function createSiputzxSticker(text, style = 'default') {
    try {
        const stickerData = await stickerAPI.createSticker(text, style);
        return stickerData.buffer;
    } catch (error) {
        console.error('Siputzx Sticker Error:', error);
        throw new Error(`Gagal membuat sticker: ${error.message}`);
    }
}

// ==================== RANDOM QUOTES (SIPUTZX) ====================
async function getRandomQuotes(category = 'random') {
    try {
        const response = await axios.get(`${SIPUTZX_API}/quotes/${category}`, {
            timeout: 10000
        });

        if (response.data?.status) {
            return {
                success: true,
                quote: response.data.data.quote,
                author: response.data.data.author || 'Unknown',
                category: response.data.data.category || category
            };
        }
        
        return {
            success: false,
            quote: "Hidup adalah perjalanan, bukan tujuan.",
            author: "Ralph Waldo Emerson",
            category: "inspiration"
        };
    } catch (error) {
        return {
            success: false,
            quote: "Kesuksesan bukanlah kunci kebahagiaan. Kebahagiaanlah kunci kesuksesan.",
            author: "Albert Schweitzer",
            category: "motivation"
        };
    }
}

// ==================== RANDOM FACTS (SIPUTZX) ====================
async function getRandomFacts(type = 'random') {
    try {
        const response = await axios.get(`${SIPUTZX_API}/facts/${type}`, {
            timeout: 10000
        });

        if (response.data?.status) {
            return {
                success: true,
                fact: response.data.data.fact,
                type: response.data.data.type || type
            };
        }
        
        return {
            success: false,
            fact: "Lebah madu harus mengunjungi sekitar 2 juta bunga untuk membuat 500 gram madu.",
            type: "science"
        };
    } catch (error) {
        return {
            success: false,
            fact: "Manusia menghabiskan sekitar 25 tahun dari hidupnya untuk tidur.",
            type: "human"
        };
    }
}

// ==================== FUNGSI UTILITY TAMBAHAN ====================
function calculateTimeAgo(timestamp) {
    if (!timestamp) return 'Unknown';
    
    try {
        let uploadDate;
        
        if (typeof timestamp === 'number') {
            if (timestamp < 10000000000) {
                uploadDate = new Date(timestamp * 1000);
            } else {
                uploadDate = new Date(timestamp);
            }
        } else if (typeof timestamp === 'string') {
            if (/^\d{8}$/.test(timestamp)) {
                const year = timestamp.substring(0, 4);
                const month = timestamp.substring(4, 6);
                const day = timestamp.substring(6, 8);
                uploadDate = new Date(`${year}-${month}-${day}`);
            } else {
                uploadDate = new Date(timestamp);
            }
        } else {
            return 'Unknown';
        }
        
        if (isNaN(uploadDate.getTime())) {
            return 'Unknown';
        }
        
        const now = new Date();
        const diffTime = Math.abs(now - uploadDate);
        const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
        
        if (diffDays === 0) return 'Hari ini';
        else if (diffDays === 1) return '1 hari yang lalu';
        else if (diffDays < 7) return `${diffDays} hari yang lalu`;
        else if (diffDays < 30) {
            const weeks = Math.floor(diffDays / 7);
            return `${weeks} minggu yang lalu`;
        } else if (diffDays < 365) {
            const months = Math.floor(diffDays / 30);
            return `${months} bulan yang lalu`;
        } else {
            const years = Math.floor(diffDays / 365);
            return `${years} tahun yang lalu`;
        }
    } catch (error) {
        console.error('Error calculating time ago:', error);
        return 'Unknown';
    }
}

function formatDuration(seconds) {
    if (!seconds) return 'Unknown';
    
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);
    
    if (hours > 0) {
        return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    } else {
        return `${minutes}:${secs.toString().padStart(2, '0')}`;
    }
}

function formatFileSize(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
}

function sanitizeInput(input) {
    if (typeof input !== 'string') return '';
    return input
        .replace(/[<>]/g, '')
        .substring(0, 1000)
        .trim();
}

function validateUrl(url) {
    try {
        const urlObj = new URL(url);
        const allowedDomains = [
            'youtube.com', 'youtu.be', 'tiktok.com', 'vm.tiktok.com',
            'instagram.com', 'facebook.com', 'twitter.com',
            'mediafire.com', 'spotify.com', 'open.spotify.com'
        ];
        
        return allowedDomains.some(domain => urlObj.hostname.includes(domain));
    } catch {
        return false;
    }
}

function delay(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

// ==================== MEMORY MANAGEMENT ====================
class MemoryManager {
    constructor() {
        this.cleanupInterval = setInterval(() => {
            this.cleanupOldData();
        }, 30 * 60 * 1000);
    }

    cleanupOldData() {
        const now = Date.now();
        const oneHour = 60 * 60 * 1000;
        
        for (const [key, timestamp] of userCooldowns.entries()) {
            if (now - timestamp > oneHour) {
                userCooldowns.delete(key);
            }
        }
        
        for (const [id, media] of viewOnceMedia.entries()) {
            if (now - parseInt(id) > 3600000) {
                if (fs.existsSync(media.filepath)) {
                    fs.unlinkSync(media.filepath);
                }
                viewOnceMedia.delete(id);
            }
        }
        
        console.log('üßπ Memory cleanup completed');
    }

    destroy() {
        if (this.cleanupInterval) {
            clearInterval(this.cleanupInterval);
        }
    }
}

const memoryManager = new MemoryManager();

// ==================== ERROR HANDLER ====================
class ErrorHandler {
    static handleCommandError(error, command, jid, sock, originalMsg) {
        console.error(`‚ùå Error in command ${command}:`, error);
        
        const errorMessages = {
            'ENOTFOUND': 'Koneksi internet bermasalah',
            'ECONNRESET': 'Koneksi terputus',
            'ETIMEDOUT': 'Timeout, coba lagi',
            'UNAUTHORIZED': 'API key tidak valid',
            'NOT_FOUND': 'Data tidak ditemukan'
        };
        
        const userMessage = errorMessages[error.code] || 
                           error.message || 
                           'Terjadi kesalahan sistem';
        
        try {
            sock.sendMessage(jid, { 
                text: `‚ùå *ERROR* ‚ùå\n\nCommand: ${command}\nError: ${userMessage}\n\nCoba lagi beberapa saat.` 
            }, { quoted: originalMsg }).catch(e => {
                console.error('Gagal mengirim error message:', e);
            });
        } catch (e) {
            console.error('Gagal mengirim error message:', e);
        }
    }
    
    static async safeExecute(sock, jid, fn, originalMsg, command = 'unknown') {
        try {
            return await fn();
        } catch (error) {
            this.handleCommandError(error, command, jid, sock, originalMsg);
            return null;
        }
    }
}

// ==================== SISTEM LEVEL & ECONOMY ====================
class EconomySystem {
    constructor() {
        this.users = new Map();
        this.shopItems = [
            { id: 1, name: 'üíé Diamond', price: 1000, description: 'Item langka untuk koleksi' },
            { id: 2, name: 'üçñ Makanan', price: 100, description: 'Mengembalikan 10 HP' },
            { id: 3, name: '‚öîÔ∏è Pedang', price: 500, description: 'Meningkatkan attack +10' },
            { id: 4, name: 'üõ°Ô∏è Perisai', price: 400, description: 'Meningkatkan defense +8' },
            { id: 5, name: 'üß™ Potion', price: 300, description: 'Mengembalikan 50 HP' }
        ];
    }

    getUser(userId) {
        if (!this.users.has(userId)) {
            this.users.set(userId, {
                money: 1000,
                bank: 0,
                level: 1,
                exp: 0,
                inventory: [],
                health: 100,
                attack: 10,
                defense: 5,
                lastDaily: 0,
                lastWork: 0
            });
        }
        return this.users.get(userId);
    }

    addMoney(userId, amount) {
        const user = this.getUser(userId);
        user.money += amount;
        return user.money;
    }

    addExp(userId, exp) {
        const user = this.getUser(userId);
        user.exp += exp;
        
        const expNeeded = user.level * 100;
        if (user.exp >= expNeeded) {
            user.level += 1;
            user.exp = user.exp - expNeeded;
            user.money += user.level * 50;
            return { leveledUp: true, newLevel: user.level };
        }
        return { leveledUp: false };
    }

    dailyReward(userId) {
        const user = this.getUser(userId);
        const now = Date.now();
        const oneDay = 24 * 60 * 60 * 1000;

        if (now - user.lastDaily < oneDay) {
            const nextDaily = user.lastDaily + oneDay;
            const timeLeft = nextDaily - now;
            const hours = Math.floor(timeLeft / (1000 * 60 * 60));
            const minutes = Math.floor((timeLeft % (1000 * 60 * 60)) / (1000 * 60));
            return { success: false, timeLeft: `${hours} jam ${minutes} menit` };
        }

        const reward = 500 + (user.level * 50);
        user.money += reward;
        user.lastDaily = now;
        return { success: true, amount: reward };
    }

    work(userId) {
        const user = this.getUser(userId);
        const now = Date.now();
        const oneHour = 60 * 60 * 1000;

        if (now - user.lastWork < oneHour) {
            const nextWork = user.lastWork + oneHour;
            const timeLeft = nextWork - now;
            const minutes = Math.floor(timeLeft / (1000 * 60));
            return { success: false, timeLeft: `${minutes} menit` };
        }

        const earnings = 100 + (Math.floor(Math.random() * 50) + user.level * 10);
        user.money += earnings;
        user.lastWork = now;
        const expGain = Math.floor(Math.random() * 10) + 5;
        this.addExp(userId, expGain);

        return { success: true, amount: earnings, exp: expGain };
    }

    buyItem(userId, itemId) {
        const user = this.getUser(userId);
        const item = this.shopItems.find(i => i.id === itemId);
        
        if (!item) return { success: false, message: 'Item tidak ditemukan' };
        if (user.money < item.price) return { success: false, message: 'Uang tidak cukup' };

        user.money -= item.price;
        user.inventory.push(item);
        return { success: true, item: item };
    }

    getUserStats(userId) {
        const user = this.getUser(userId);
        return user;
    }
}

const economy = new EconomySystem();

// ==================== SISTEM GAME ====================
class GameSystem {
    constructor() {
        this.games = new Map();
    }

    startTebakKata(jid, answer, hint) {
        const gameId = Date.now().toString();
        this.games.set(gameId, {
            type: 'tebak-kata',
            jid: jid,
            answer: answer.toLowerCase(),
            hint: hint,
            startedAt: Date.now(),
            attempts: 0,
            maxAttempts: 5
        });
        return gameId;
    }

    checkTebakKata(gameId, guess) {
        const game = this.games.get(gameId);
        if (!game) return { valid: false, message: 'Game tidak ditemukan' };

        game.attempts++;
        const isCorrect = guess.toLowerCase() === game.answer;

        if (isCorrect) {
            this.games.delete(gameId);
            return { valid: true, correct: true, attempts: game.attempts };
        }

        if (game.attempts >= game.maxAttempts) {
            this.games.delete(gameId);
            return { valid: true, correct: false, gameOver: true, answer: game.answer };
        }

        const hints = this.generateHint(game.answer, game.attempts);
        return { 
            valid: true, 
            correct: false, 
            attempts: game.attempts, 
            maxAttempts: game.maxAttempts,
            hint: hints
        };
    }

    generateHint(answer, attempt) {
        const hints = [];
        const words = answer.split(' ');
        
        words.forEach(word => {
            if (attempt === 1) {
                hints.push('_'.repeat(word.length));
            } else if (attempt === 2) {
                hints.push(word[0] + '_'.repeat(word.length - 1));
            } else if (attempt === 3) {
                hints.push(word[0] + '_'.repeat(word.length - 2) + (word.length > 1 ? word[word.length - 1] : ''));
            } else {
                hints.push(word);
            }
        });
        
        return hints.join(' ');
    }

    startMathQuiz(jid, difficulty = 'medium') {
        const gameId = Date.now().toString();
        const { question, answer } = this.generateMathQuestion(difficulty);
        
        this.games.set(gameId, {
            type: 'math-quiz',
            jid: jid,
            question: question,
            answer: answer,
            startedAt: Date.now(),
            difficulty: difficulty
        });
        
        return { gameId, question };
    }

    generateMathQuestion(difficulty) {
        let a, b, operator, answer, question;
        
        switch(difficulty) {
            case 'easy':
                a = Math.floor(Math.random() * 10) + 1;
                b = Math.floor(Math.random() * 10) + 1;
                operator = ['+', '-'][Math.floor(Math.random() * 2)];
                break;
            case 'medium':
                a = Math.floor(Math.random() * 50) + 1;
                b = Math.floor(Math.random() * 50) + 1;
                operator = ['+', '-', '*'][Math.floor(Math.random() * 3)];
                break;
            case 'hard':
                a = Math.floor(Math.random() * 100) + 1;
                b = Math.floor(Math.random() * 100) + 1;
                operator = ['+', '-', '*', '/'][Math.floor(Math.random() * 4)];
                if (operator === '/') {
                    b = Math.floor(Math.random() * 10) + 1;
                    a = b * Math.floor(Math.random() * 10) + 1;
                }
                break;
        }

        switch(operator) {
            case '+': answer = a + b; break;
            case '-': answer = a - b; break;
            case '*': answer = a * b; break;
            case '/': answer = a / b; break;
        }

        question = `${a} ${operator} ${b}`;
        return { question, answer };
    }

    checkMathQuiz(gameId, userAnswer) {
        const game = this.games.get(gameId);
        if (!game) return { valid: false, message: 'Game tidak ditemukan' };

        const isCorrect = parseInt(userAnswer) === game.answer;
        this.games.delete(gameId);

        return { valid: true, correct: isCorrect, answer: game.answer };
    }
}

const gameSystem = new GameSystem();

// ==================== SISTEM WELCOME & LEAVE ====================
class WelcomeSystem {
    constructor() {
        this.groupSettings = new Map();
    }

    setWelcomeMessage(jid, message) {
        if (!this.groupSettings.has(jid)) {
            this.groupSettings.set(jid, {});
        }
        const settings = this.groupSettings.get(jid);
        settings.welcomeMessage = message;
        settings.welcomeEnabled = true;
        return true;
    }

    setLeaveMessage(jid, message) {
        if (!this.groupSettings.has(jid)) {
            this.groupSettings.set(jid, {});
        }
        const settings = this.groupSettings.get(jid);
        settings.leaveMessage = message;
        settings.leaveEnabled = true;
        return true;
    }

    disableWelcome(jid) {
        const settings = this.groupSettings.get(jid);
        if (settings) {
            settings.welcomeEnabled = false;
            return true;
        }
        return false;
    }

    disableLeave(jid) {
        const settings = this.groupSettings.get(jid);
        if (settings) {
            settings.leaveEnabled = false;
            return true;
        }
        return false;
    }

    getWelcomeMessage(jid, user, group) {
        const settings = this.groupSettings.get(jid);
        if (!settings || !settings.welcomeEnabled) return null;

        let message = settings.welcomeMessage || 
            `Selamat datang @${user.split('@')[0]} di grup ${group}!\n\nSemoga betah ya! üòä`;
        
        message = message
            .replace(/{user}/g, `@${user.split('@')[0]}`)
            .replace(/{group}/g, group)
            .replace(/{time}/g, new Date().toLocaleString('id-ID'));
        
        return message;
    }

    getLeaveMessage(jid, user, group) {
        const settings = this.groupSettings.get(jid);
        if (!settings || !settings.leaveEnabled) return null;

        let message = settings.leaveMessage || 
            `Selamat tinggal @${user.split('@')[0]} dari grup ${group}!\n\nSemoga sukses selalu! üôè`;
        
        message = message
            .replace(/{user}/g, `@${user.split('@')[0]}`)
            .replace(/{group}/g, group)
            .replace(/{time}/g, new Date().toLocaleString('id-ID'));
        
        return message;
    }
}

const welcomeSystem = new WelcomeSystem();

// ==================== UTILITY FUNCTIONS ====================
function formatPhoneNumber(jid) {
    if (!jid) return 'Unknown';
    return jid.replace('@s.whatsapp.net', '').replace('@g.us', ' (Group)');
}

async function sendTypingIndicator(sock, jid, duration = 3000) {
    try {
        await sock.sendPresenceUpdate('composing', jid);
        
        setTimeout(async () => {
            try {
                await sock.sendPresenceUpdate('paused', jid);
            } catch (error) {
                console.log('Error pausing typing indicator:', error);
            }
        }, duration);

    } catch (error) {
        console.log('Error typing indicator:', error);
    }
}

function checkCooldown(jid, command, cooldownTime = 3000) {
    const key = `${jid}_${command}`;
    const now = Date.now();
    const lastUsed = userCooldowns.get(key);
    
    if (lastUsed && (now - lastUsed) < cooldownTime) {
        return false;
    }
    
    userCooldowns.set(key, now);
    return true;
}

function logUserActivity(jid, message, command = null) {
    if (!jid) {
        console.error('JID is undefined in logUserActivity');
        return;
    }

    const phone = formatPhoneNumber(jid);
    const timestamp = new Date().toLocaleString('id-ID');

    if (!userDatabase.has(jid)) {
        userCounter++;
        userDatabase.set(jid, {
            id: userCounter,
            phone: phone,
            firstSeen: timestamp,
            lastActive: timestamp,
            commandCount: 0,
            messageCount: 0,
            commands: [],
            lastInteraction: Date.now()
        });
    }

    const userData = userDatabase.get(jid);
    userData.lastActive = timestamp;
    userData.messageCount++;
    userData.lastInteraction = Date.now();

    if (command) {
        userData.commandCount++;
        userData.commands.push({ command, timestamp });

        console.log('\n' + '='.repeat(60));
        console.log('üë§ COMMAND DETECTED!');
        console.log('='.repeat(60));
        console.log(`üë§ User ID      : #${userData.id}`);
        console.log(`üì± Nomor       : ${phone}`);
        console.log(`üåÄ Command     : ${command}`);
        console.log(`üí¨ Pesan       : ${message}`);
        console.log(`üïí Waktu       : ${timestamp}`);
        console.log(`üìä Total Cmd   : ${userData.commandCount}`);
        console.log(`üìà Total Msg   : ${userData.messageCount}`);
        console.log(`üîç First Seen  : ${userData.firstSeen}`);
        console.log('='.repeat(60));

        if (userData.commands.length > 0) {
            console.log('üìã Command History (5 terbaru):');
            const recentCommands = userData.commands.slice(-5);
            recentCommands.forEach((cmd, idx) => {
                console.log(`   ${idx + 1}. ${cmd.command} - ${cmd.timestamp}`);
            });
            console.log('='.repeat(60));
        }
    } else {
        console.log(`[${timestamp}] üí¨ ${phone}: ${message}`);
    }
}

function createReplyContext(quotedMsg) {
    if (!quotedMsg || !quotedMsg.key) return {};
    
    return {
        contextInfo: {
            stanzaId: quotedMsg.key.id,
            participant: quotedMsg.key.participant || quotedMsg.key.remoteJid,
            quotedMessage: quotedMsg.message,
            remoteJid: quotedMsg.key.remoteJid
        }
    };
}

async function sendReply(sock, jid, text, quotedMsg, options = {}) {
    try {
        const replyContext = createReplyContext(quotedMsg);
        const messageOptions = {
            ...options,
            ...replyContext
        };
        
        return await sock.sendMessage(jid, { text }, messageOptions);
    } catch (error) {
        console.error('Error sending reply:', error);
        throw error;
    }
}

async function sendReplyWithReaction(sock, jid, text, quotedMsg, options = {}) {
    try {
        if (quotedMsg && quotedMsg.key) {
            await reactionSystem.sendReaction(sock, jid, quotedMsg.key, 'loading');
        }
        
        await delay(2000 + Math.random() * 1000);
        
        const message = await sendReply(sock, jid, text, quotedMsg, options);
        
        if (quotedMsg && quotedMsg.key) {
            setTimeout(async () => {
                await reactionSystem.updateReaction(sock, jid, quotedMsg.key, 'success');
            }, 1000);
        }
        
        return message;
    } catch (error) {
        console.error('Error in sendReplyWithReaction:', error);
        
        if (quotedMsg && quotedMsg.key) {
            await reactionSystem.updateReaction(sock, jid, quotedMsg.key, 'error');
        }
        
        throw error;
    }
}

async function processCommandWithReaction(sock, jid, quotedMsg, commandName, processFunction) {
    try {
        if (quotedMsg && quotedMsg.key) {
            await reactionSystem.sendReaction(sock, jid, quotedMsg.key, 'loading');
        }
        
        console.log(`üîÑ [${commandName}] Memulai proses...`);
        
        await delay(2000 + Math.random() * 1000);
        
        const result = await processFunction();
        
        if (quotedMsg && quotedMsg.key) {
            await reactionSystem.updateReaction(sock, jid, quotedMsg.key, 'success');
        }
        
        console.log(`‚úÖ [${commandName}] Proses selesai`);
        
        return result;
    } catch (error) {
        console.error(`‚ùå [${commandName}] Error:`, error);
        
        if (quotedMsg && quotedMsg.key) {
            await reactionSystem.updateReaction(sock, jid, quotedMsg.key, 'error');
        }
        
        throw error;
    }
}

// ==================== HANDLER UNTUK FITUR SIPUTZX BARU ====================

// ==================== AI CHAT (SIPUTZX) ====================
async function handleSiputzxAI(sock, jid, msg, args, pushName, originalMsg) {
    if (args.length < 1) {
        await sendReplyWithReaction(sock, jid,
            `ü§ñ *SIPUTZX AI CHAT* ü§ñ\n\n` +
            `Chat dengan AI cerdas dari Siputzx API\n\n` +
            `üìå *Perintah:*\n` +
            `‚Ä¢ .ai [pertanyaan] - Chat dengan AI\n` +
            `‚Ä¢ .clearai - Hapus history chat\n\n` +
            `üí° *Contoh:*\n` +
            `.ai Apa itu artificial intelligence?\n` +
            `.ai Buatkan puisi tentang alam\n` +
            `.clearai`,
            originalMsg
        );
        return;
    }

    if (args[0].toLowerCase() === 'clear') {
        siputzxAI.clearHistory(jid);
        await sendReplyWithReaction(sock, jid, "‚úÖ History percakapan AI telah dihapus!", originalMsg);
        return;
    }

    const userMessage = args.join(' ');

    await processCommandWithReaction(sock, jid, originalMsg, 'SIPUTZX_AI', async () => {
        const aiResponse = await siputzxAI.chat(userMessage, jid);
        
        await sendReply(sock, jid,
            `ü§ñ *SIPUTZX AI:*\n\n${aiResponse.response}\n\n` +
            `üë§ *Pengguna:* ${pushName}\n` +
            `üïí *Waktu:* ${new Date().toLocaleString('id-ID')}`,
            originalMsg
        );
    });
}

// ==================== STICKER MAKER (SIPUTZX) ====================
async function handleSiputzxSticker(sock, jid, msg, args, pushName, originalMsg) {
    if (args.length < 1) {
        await sendReplyWithReaction(sock, jid,
            `üõ†Ô∏è *SIPUTZX STICKER MAKER* üõ†Ô∏è\n\n` +
            `Buat sticker dari teks dengan berbagai style\n\n` +
            `üìå *Format:* .smaker [teks] -style [style]\n\n` +
            `üé® *Available Styles:*\n` +
            `‚Ä¢ default - Style default\n` +
            `‚Ä¢ bold - Teks tebal\n` +
            `‚Ä¢ rainbow - Warna pelangi\n` +
            `‚Ä¢ outline - Outline teks\n` +
            `‚Ä¢ shadow - Dengan bayangan\n` +
            `‚Ä¢ funny - Style lucu\n\n` +
            `üí° *Contoh:*\n` +
            `.smaker Hello World\n` +
            `.smaker Halo semua -style rainbow\n` +
            `.smaker Test sticker -style shadow`,
            originalMsg
        );
        return;
    }

    let text = '';
    let style = 'default';
    const parsedArgs = [];

    for (let i = 0; i < args.length; i++) {
        if (args[i] === '-style' && args[i + 1]) {
            style = args[i + 1];
            i++;
        } else {
            parsedArgs.push(args[i]);
        }
    }

    text = parsedArgs.join(' ');

    if (text.length > 100) {
        await sendReplyWithReaction(sock, jid, "‚ùå Teks terlalu panjang! Maksimal 100 karakter.", originalMsg);
        return;
    }

    await processCommandWithReaction(sock, jid, originalMsg, 'SIPUTZX_STICKER', async () => {
        const stickerData = await stickerAPI.createSticker(text, style);
        
        await sock.sendMessage(jid, {
            sticker: stickerData.buffer,
            ...createReplyContext(originalMsg)
        });

        await sendReply(sock, jid,
            `‚úÖ *STICKER BERHASIL DIBUAT!* ‚úÖ\n\n` +
            `üë§ Oleh: ${pushName}\n` +
            `üí¨ Teks: "${text.substring(0, 50)}${text.length > 50 ? '...' : ''}"\n` +
            `üé® Style: ${style}\n` +
            `üõ†Ô∏è API: ${stickerData.api}\n` +
            `üìä Ukuran: ${formatFileSize(stickerData.size)}\n\n` +
            `üèÜ Sticker siap digunakan!`,
            originalMsg
        );
    });
}

// ==================== RANDOM QUOTES ====================
async function handleRandomQuotes(sock, jid, msg, args, pushName, originalMsg) {
    const category = args[0]?.toLowerCase() || 'random';

    if (category === 'categories') {
        await sendReplyWithReaction(sock, jid,
            `üìö *KATEGORI QUOTES* üìö\n\n` +
            `‚Ä¢ random - Random semua kategori\n` +
            `‚Ä¢ motivation - Motivasi hidup\n` +
            `‚Ä¢ love - Cinta dan kasih sayang\n` +
            `‚Ä¢ success - Kesuksesan\n` +
            `‚Ä¢ wisdom - Kebijaksanaan\n` +
            `‚Ä¢ funny - Lucu dan humor\n` +
            `‚Ä¢ inspirational - Inspirasi\n\n` +
            `üí° *Contoh:*\n` +
            `.quotes motivation\n` +
            `.quotes love`,
            originalMsg
        );
        return;
    }

    await processCommandWithReaction(sock, jid, originalMsg, 'QUOTES', async () => {
        const quotesData = await getRandomQuotes(category);
        
        await sendReply(sock, jid,
            `üìñ *KATA MUTIARA* üìñ\n\n` +
            `"${quotesData.quote}"\n\n` +
            `üë§ *Penulis:* ${quotesData.author}\n` +
            `üè∑Ô∏è *Kategori:* ${quotesData.category}\n` +
            `üë§ *Untuk:* ${pushName}\n\n` +
            `üí° Semoga menginspirasi harimu!`,
            originalMsg
        );
    });
}

// ==================== RANDOM FACTS ====================
async function handleRandomFacts(sock, jid, msg, args, pushName, originalMsg) {
    const type = args[0]?.toLowerCase() || 'random';

    if (type === 'types') {
        await sendReplyWithReaction(sock, jid,
            `üî¨ *JENIS FAKTA* üî¨\n\n` +
            `‚Ä¢ random - Random semua jenis\n` +
            `‚Ä¢ science - Fakta ilmiah\n` +
            `‚Ä¢ history - Fakta sejarah\n` +
            `‚Ä¢ animal - Fakta hewan\n` +
            `‚Ä¢ human - Fakta manusia\n` +
            `‚Ä¢ technology - Fakta teknologi\n` +
            `‚Ä¢ space - Fakta luar angkasa\n\n` +
            `üí° *Contoh:*\n` +
            `.fakta science\n` +
            `.fakta animal`,
            originalMsg
        );
        return;
    }

    await processCommandWithReaction(sock, jid, originalMsg, 'FACTS', async () => {
        const factsData = await getRandomFacts(type);
        
        await sendReply(sock, jid,
            `üîç *FAKTA UNIK* üîç\n\n` +
            `${factsData.fact}\n\n` +
            `üè∑Ô∏è *Jenis:* ${factsData.type}\n` +
            `üë§ *Untuk:* ${pushName}\n\n` +
            `üí° Pengetahuan baru hari ini!`,
            originalMsg
        );
    });
}

// ==================== FITUR STOK BLOX FRUITS ====================
async function getBloxFruitStock() {
    try {
        const { data: html } = await axios.get('https://fruityblox.com/stock', {
            headers: {
                'User-Agent': 'Mozilla/5.0 (Linux; Android 10)'
            },
            timeout: 15000
        });

        const $ = cheerio.load(html);
        const allStock = [];

        $('.p-4.border').each((_, el) => {
            const $el = $(el);
            const name = $el.find('h3.font-medium').text().trim();
            const stockType = $el.find('span.text-xs').text().trim();
            const priceSpans = $el.find('span.text-sm');
            const priceMoney = $(priceSpans[0]).text().replace('$', '').trim();
            const priceRobux = $(priceSpans[1]).text().replace('R', '').trim();
            
            allStock.push({
                name,
                stockType,
                priceMoney,
                priceRobux
            });
        });

        const normalStock = allStock.filter(fruit => 
            fruit.stockType.includes('Normal') || 
            fruit.stockType.includes('Stock')
        );
        
        const mirageStock = allStock.filter(fruit => 
            fruit.stockType.includes('Mirage')
        );

        const updateTextElements = $('div.bg-white\\/10 p.text-sm');
        const normalUpdatedAt = updateTextElements.eq(0).text().includes('UPDATE:') 
            ? updateTextElements.eq(0).text().replace('UPDATE:', '').trim() 
            : 'Unknown';
            
        const mirageUpdatedAt = updateTextElements.eq(1).text().includes('UPDATE:') 
            ? updateTextElements.eq(1).text().replace('UPDATE:', '').trim() 
            : 'Unknown';

        return {
            author: 'xZiyy',
            normal: {
                updatedAt: normalUpdatedAt,
                stock: normalStock
            },
            mirage: {
                updatedAt: mirageUpdatedAt,
                stock: mirageStock
            },
            all: {
                updatedAt: new Date().toLocaleString('id-ID'),
                stock: allStock
            }
        };
    } catch (err) {
        throw new Error(`Gagal ambil data: ${err.message}`);
    }
}

async function handleStokBF(sock, jid, msg, args, pushName, originalMsg) {
    await processCommandWithReaction(sock, jid, originalMsg, 'STOK_BF', async () => {
        const stockData = await getBloxFruitStock();
        
        let normalText = `üçé *STOK NORMAL BLOX FRUITS* üçé\n`;
        normalText += `üìÖ Update: ${stockData.normal.updatedAt}\n\n`;
        
        if (stockData.normal.stock.length === 0) {
            normalText += `‚ùå *Tidak ada stock normal saat ini*\n`;
        } else {
            stockData.normal.stock.forEach((fruit, index) => {
                normalText += `${index + 1}. *${fruit.name}*\n`;
                normalText += `   üí∞ $${fruit.priceMoney} | ü™ô R${fruit.priceRobux}\n`;
                normalText += `   üìä ${fruit.stockType}\n\n`;
            });
        }

        await sendReply(sock, jid, normalText, originalMsg);

        const infoText = `üìä *INFO STOK BLOX FRUITS*\n\n` +
                       `üçé Total Normal: ${stockData.normal.stock.length} buah\n` +
                       `üåÄ Total Mirage: ${stockData.mirage.stock.length} buah\n` +
                       `üìà Total Semua: ${stockData.all.stock.length} buah\n` +
                       `üåÄ Powered by: ${stockData.author}\n` +
                       `üïí Data diambil: ${stockData.all.updatedAt}\n\n` +
                       `üí° Gunakan *.stokmirage* untuk cek stok mirage!`;

        await sendReply(sock, jid, infoText, originalMsg);
    });
}

async function handleStokMirage(sock, jid, msg, args, pushName, originalMsg) {
    await processCommandWithReaction(sock, jid, originalMsg, 'STOK_MIRAGE', async () => {
        const stockData = await getBloxFruitStock();
        
        let mirageText = `üåÄ *STOK MIRAGE BLOX FRUITS* üåÄ\n`;
        mirageText += `üìÖ Update: ${stockData.mirage.updatedAt}\n\n`;
        
        if (stockData.mirage.stock.length === 0) {
            mirageText += `‚ùå *Tidak ada stock mirage saat ini*\n`;
            mirageText += `üí° Stock mirage biasanya tersedia saat event tertentu!\n`;
        } else {
            stockData.mirage.stock.forEach((fruit, index) => {
                mirageText += `${index + 1}. *${fruit.name}*\n`;
                mirageText += `   üí∞ $${fruit.priceMoney} | ü™ô R${fruit.priceRobux}\n`;
                mirageText += `   üìä ${fruit.stockType}\n\n`;
            });
        }

        await sendReply(sock, jid, mirageText, originalMsg);

        const infoText = `üìä *INFO STOK MIRAGE*\n\n` +
                       `üåÄ Total Mirage: ${stockData.mirage.stock.length} buah\n` +
                       `üçé Total Normal: ${stockData.normal.stock.length} buah\n` +
                       `üåÄ Powered by: ${stockData.author}\n` +
                       `üïí Data diambil: ${stockData.all.updatedAt}\n\n` +
                       `üí° Gunakan *.stokbf* untuk cek stok normal!`;

        await sendReply(sock, jid, infoText, originalMsg);
    });
}

// ==================== FITUR BRAT/STICKER TEXT ====================
async function downloadBratSticker(text) {
    if (!text || text.trim().length === 0) throw new Error("Text tidak boleh kosong!");

    const clairityApi = `https://brat.caliphdev.com/api/brat?text=${encodeURIComponent(text.trim())}`;
    const siputApi = `https://clairity.dpdns.org/api/brat?text=${encodeURIComponent(text.trim())}`;

    try {
        let response = await axios.get(clairityApi, { responseType: 'arraybuffer' });
        if (!response.data || response.data.byteLength === 0) throw new Error('Clairity API kosong');

        return await sharp(response.data).webp({ lossless: true, quality: 100, alphaQuality: 100 }).toBuffer();
    } catch (err1) {
        console.warn('API Clairity gagal, coba Siput:', err1.message);
        try {
            let response = await axios.get(siputApi, { responseType: 'arraybuffer' });
            if (!response.data || response.data.byteLength === 0) throw new Error('Siput API kosong');

            return await sharp(response.data).webp({ lossless: true, quality: 100, alphaQuality: 100 }).toBuffer();
        } catch (err2) {
            console.warn('Kedua API gagal, bikin stiker lokal:', err2.message);
            return await createLocalBratSticker(text);
        }
    }
}

async function createLocalBratSticker(text) {
    try {
        const width = 512;
        const height = 512;
        
        const svgBuffer = Buffer.from(`
            <svg width="${width}" height="${height}">
                <rect width="100%" height="100%" fill="white"/>
                <text x="50%" y="50%" font-family="Arial" font-size="40" 
                      text-anchor="middle" dominant-baseline="middle" fill="black">
                    ${text}
                </text>
            </svg>
        `);
        
        const webpBuffer = await sharp(svgBuffer)
            .resize(width, height)
            .webp({ lossless: true, quality: 100 })
            .toBuffer();
            
        return webpBuffer;
    } catch (error) {
        throw new Error(`Gagal membuat stiker lokal: ${error.message}`);
    }
}

async function handleBratSticker(sock, jid, msg, args, pushName, originalMsg) {
    if (args.length < 1) {
        await sendReplyWithReaction(sock, jid, 
            `üõ†Ô∏è *FITUR BRAT/STICKER TEXT* üõ†Ô∏è\n\n` +
            `Buat stiker dari teks dengan style brat\n\n` +
            `**Format:** .brat [teks]\n` +
            `**Contoh:** .brat Hello World\n\n` +
            `**Alias:** .sbrat\n\n` +
            `‚ö†Ô∏è **Jangan ada spasi setelah titik!**\n` +
            `‚úÖ Benar: .brat halo\n` +
            `‚ùå Salah: . brat halo`,
            originalMsg
        );
        return;
    }

    const text = args.join(' ');
    
    const commandText = msg.message?.conversation || msg.message?.extendedTextMessage?.text || '';
    if (commandText.startsWith('. brat') || commandText.startsWith('. Brat')) {
        await sendReplyWithReaction(sock, jid, '‚ùå Jangan ada spasi antara titik dan brat!!', originalMsg);
        return;
    }

    await processCommandWithReaction(sock, jid, originalMsg, 'BRAT_STICKER', async () => {
        console.log(`üõ†Ô∏è Membuat stiker brat: "${text}"`);
        
        const stickerBuffer = await downloadBratSticker(text);
        
        await sock.sendMessage(jid, {
            sticker: stickerBuffer,
            ...createReplyContext(originalMsg)
        }).catch(error => {
            console.error('Error sending sticker:', error);
            throw error;
        });
    });
}

// ==================== FITUR GEMINI ====================
async function geminiChat(prompt, conversationHistory = []) {
    if (!GEMINI_API_KEY) throw new Error("‚ùå API Key Gemini belum dikonfigurasi.");

    try {
        const messages = [
            {
                role: "user",
                parts: [{
                    text: `Kamu adalah asisten AI yang ramah dan membantu. Jawab dalam Bahasa Indonesia yang natural dan mudah dipahami.\n\n${prompt}`
                }]
            }
        ];

        if (conversationHistory.length > 0) {
            messages.unshift(...conversationHistory.slice(-10));
        }

        const response = await axios.post(
            `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${GEMINI_API_KEY}`,
            { contents: messages },
            { headers: { "Content-Type": "application/json" }, timeout: 30000 }
        );

        const text = response.data.candidates?.[0]?.content?.parts?.[0]?.text;
        if (!text) throw new Error("Tidak ada respons dari Gemini API");

        return {
            text,
            usage: response.data.usageMetadata || {}
        };
    } catch (error) {
        throw new Error(`Error Gemini API: ${error.response?.data?.error?.message || error.message}`);
    }
}

async function handleGeminiChat(sock, jid, msg, args, pushName, originalMsg) {
    if (args.length < 1) {
        await sendReplyWithReaction(sock, jid,
            `ü§ñ *GEMINI CHAT*\n\n` +
            `Chat langsung dengan AI Gemini.\n\n` +
            `üìå *Perintah:*\n` +
            `‚Ä¢ .geminichat [teks] ‚Üí Chat biasa\n` +
            `‚Ä¢ .geminichat clear ‚Üí Hapus history chat\n\n` +
            `üí° Gemini akan mengingat 10 pesan terakhir.`,
            originalMsg
        );
        return;
    }

    if (args[0].toLowerCase() === "clear") {
        geminiConversations.delete(jid);
        await sendReplyWithReaction(sock, jid, "‚úÖ History percakapan Gemini telah dihapus!", originalMsg);
        return;
    }

    const text = args.join(" ");

    await processCommandWithReaction(sock, jid, originalMsg, 'GEMINI_CHAT', async () => {
        if (!geminiConversations.has(jid)) geminiConversations.set(jid, []);
        const history = geminiConversations.get(jid);

        const response = await geminiChat(text, history);
        history.push(
            { role: "user", parts: [{ text }] },
            { role: "model", parts: [{ text: response.text }] }
        );
        if (history.length > 20) history.splice(0, history.length - 20);

        await sendReply(sock, jid,
            `ü§ñ *Gemini AI:*\n\n${response.text}\n\n` +
            `_üí° Token: ${response.usage.totalTokens || "N/A"} | Total chat: ${history.length / 2}_`,
            originalMsg
        );
    });
}

// ==================== FITUR CHATBOT SAMSIMI ====================
const samsimiResponses = {
    'halo': ['Halo juga!', 'Hai!', 'Halo, ada yang bisa saya bantu?', 'Halo ganteng/cantik!'],
    'hai': ['Hai juga!', 'Halo!', 'Hai, apa kabar?'],
    'test': ['Test berhasil!', 'Bot aktif!', 'Halo, saya di sini!'],
    'bot': ['Iya, saya bot!', 'Ada yang bisa saya bantu?', 'Halo, saya bot WhatsApp!'],
    'owner': ['Owner saya Adit!', 'WhatsApp: 6283115105784', 'Hubungi Adit di 083115105784'],
};

async function samsimiChat(message) {
    const cleanMessage = message.toLowerCase().trim();
    
    for (const [key, responses] of Object.entries(samsimiResponses)) {
        if (cleanMessage.includes(key)) {
            const randomResponse = responses[Math.floor(Math.random() * responses.length)];
            return randomResponse;
        }
    }
    
    const defaultResponses = [
        'Hmm... gak ngerti deh!',
        'Apa tuh? Coba jelasin!',
        'Waduh, saya gak paham!',
        'Bisa diulang? Gak ngerti nih!',
        'Maaf, saya belum belajar itu!',
    ];
    
    return defaultResponses[Math.floor(Math.random() * defaultResponses.length)];
}

async function handleChatbot(sock, jid, msg, args, pushName, originalMsg) {
    if (args.length < 1) {
        await sendReplyWithReaction(sock, jid, 
            `ü§ñ *CHATBOT SAMSIMI MODE* ü§ñ\n\n` +
            `Cara penggunaan:\n` +
            `‚Ä¢ .chatbot [pesan] - Chat dengan bot\n` +
            `‚Ä¢ .chatbot stats - Lihat statistik chatbot\n\n` +
            `Contoh:\n` +
            `.chatbot halo\n` +
            `.chatbot apa kabar?`,
            originalMsg
        );
        return;
    }

    if (args[0] === 'stats') {
        const totalQuestions = Object.keys(samsimiResponses).length;
        let totalAnswers = 0;
        
        Object.values(samsimiResponses).forEach(responses => {
            totalAnswers += responses.length;
        });

        await sendReplyWithReaction(sock, jid, 
            `üìä *STATISTIK CHATBOT*\n\n` +
            `Total Pertanyaan: ${totalQuestions}\n` +
            `Total Jawaban: ${totalAnswers}\n\n` +
            `Bot dibuat dengan üß™ oleh Adit`,
            originalMsg
        );
        return;
    }

    const userMessage = args.join(' ');

    await processCommandWithReaction(sock, jid, originalMsg, 'CHATBOT', async () => {
        const botResponse = await samsimiChat(userMessage);
        
        if (!chatbotDatabase.has(jid)) {
            chatbotDatabase.set(jid, []);
        }
        
        const userChats = chatbotDatabase.get(jid);
        userChats.push({
            user: userMessage,
            bot: botResponse,
            timestamp: new Date().toLocaleString('id-ID')
        });

        if (userChats.length > 50) {
            userChats.splice(0, userChats.length - 50);
        }

        await sendReply(sock, jid, 
            `ü§ñ *YTZBXIW BOT*:\n${botResponse}\n\n` +
            `_Ketik .chatbot help untuk bantuan_`,
            originalMsg
        );
    });
}

// ==================== FITUR GANTI PROFILE PICTURE V2 (FOR ALL USERS) ====================
async function createCircularProfilePicture(imageBuffer) {
    try {
        const metadata = await sharp(imageBuffer).metadata();
        
        const size = Math.max(640, Math.min(metadata.width, metadata.height, 2000));
        
        const circularBuffer = await sharp(imageBuffer)
            .resize(size, size, {
                fit: 'cover',
                position: 'center'
            })
            .composite([{
                input: Buffer.from(
                    `<svg><circle cx="${size/2}" cy="${size/2}" r="${size/2}" fill="black"/></svg>`
                ),
                blend: 'dest-in'
            }])
            .png({ quality: 90 })
            .toBuffer();
            
        return circularBuffer;
    } catch (error) {
        console.error('Error creating circular image:', error);
        return imageBuffer;
    }
}

async function handleGantiPPV2(sock, jid, msg, args, pushName, originalMsg) {
    const hasImage = msg.message?.imageMessage || 
                    (msg.message?.extendedTextMessage?.contextInfo?.quotedMessage?.imageMessage);

    if (!hasImage) {
        await sendReplyWithReaction(sock, jid,
            `üñºÔ∏è *GANTI PROFILE PICTURE V2* üñºÔ∏è\n\n` +
            `Ubah foto profil WhatsApp Anda sendiri dengan gambar yang dikirim!\n\n` +
            `üìù *Cara Pakai:*\n` +
            `1. Kirim gambar yang ingin dijadikan PP\n` +
            `2. Reply gambar tersebut\n` +
            `3. Ketik *.gantippv2*\n\n` +
            `‚ö†Ô∏è *Persyaratan:*\n` +
            `‚Ä¢ Semua pengguna bisa menggunakan fitur ini\n` +
            `‚Ä¢ Ukuran gambar maksimal 5MB\n` +
            `‚Ä¢ Format: JPG, PNG, WEBP\n\n` +
            `üí° *Tips:*\n` +
            `‚Ä¢ Gambar akan otomatis di-crop menjadi bentuk lingkaran\n` +
            `‚Ä¢ Kualitas gambar akan dipertahankan\n` +
            `‚Ä¢ Pastikan gambar memiliki resolusi yang baik`,
            originalMsg
        );
        return;
    }

    await processCommandWithReaction(sock, jid, originalMsg, 'GANTI_PP_V2', async () => {
        let imageBuffer;
        
        if (msg.message?.extendedTextMessage?.contextInfo?.quotedMessage?.imageMessage) {
            const quotedMsg = {
                key: { remoteJid: jid },
                message: msg.message.extendedTextMessage.contextInfo.quotedMessage
            };
            imageBuffer = await downloadMediaMessage(quotedMsg, "buffer", {});
        } else {
            imageBuffer = await downloadMediaMessage(msg, "buffer", {});
        }

        if (!imageBuffer || imageBuffer.length === 0) {
            throw new Error('Gagal mengambil gambar. Coba dengan gambar yang berbeda.');
        }

        if (imageBuffer.length > 5 * 1024 * 1024) {
            throw new Error("Gambar terlalu besar! Maksimal 5MB.");
        }

        const fileType = await fileTypeFromBuffer(imageBuffer);
        if (!fileType || !['jpg', 'jpeg', 'png', 'webp'].includes(fileType.ext)) {
            throw new Error("Format gambar tidak didukung! Gunakan JPG, PNG, atau WEBP.");
        }

        console.log(`üñºÔ∏è Mengganti profile picture untuk ${pushName}...`);

        const circularImageBuffer = await createCircularProfilePicture(imageBuffer);

        const userJid = msg.key.participant || jid;
        
        await sock.updateProfilePicture(userJid, circularImageBuffer);

        await sendReply(sock, jid,
            `‚úÖ *PROFILE PICTURE BERHASIL DIGANTI!* ‚úÖ\n\n` +
            `üë§ Diubah oleh: ${pushName}\n` +
            `‚è∞ Waktu: ${new Date().toLocaleString('id-ID')}\n` +
            `üñºÔ∏è Format: ${fileType.ext.toUpperCase()}\n` +
            `üìä Ukuran: ${(imageBuffer.length / 1024).toFixed(2)} KB\n` +
            `‚öôÔ∏è Proses: Auto-crop lingkaran\n\n` +
            `üèÜ Profile picture Anda telah diperbarui!`,
            originalMsg
        );

        await sock.sendMessage(jid, {
            image: circularImageBuffer,
            caption: `üñºÔ∏è *PREVIEW PP BARU ANDA*\n\nIni adalah profile picture baru Anda!`,
            ...createReplyContext(originalMsg)
        }).catch(error => {
            console.error('Error sending preview:', error);
        });
    });
}

// ==================== FITUR VIEW ONCE MEDIA ====================
async function saveViewOnceMediaV2(msg, jid) {
    try {
        const messageType = Object.keys(msg.message)[0];
        
        if (!messageType.includes('viewOnceMessage')) return null;

        let viewOnceContent;
        if (messageType === 'viewOnceMessageV2') {
            viewOnceContent = msg.message.viewOnceMessageV2?.message;
        } else if (messageType === 'viewOnceMessage') {
            viewOnceContent = msg.message.viewOnceMessage?.message;
        }
        
        if (!viewOnceContent) return null;

        const mediaType = Object.keys(viewOnceContent)[0];
        if (!['imageMessage', 'videoMessage'].includes(mediaType)) {
            return null;
        }

        const mediaBuffer = await downloadMediaMessage(msg, 'buffer', {});

        const fileExt = mediaType === 'imageMessage' ? '.jpg' : '.mp4';
        const filename = `viewonce_${Date.now()}${fileExt}`;
        const filepath = path.join(tempDir, filename);

        fs.writeFileSync(filepath, mediaBuffer);

        const mediaInfo = {
            jid: jid,
            type: mediaType,
            filepath: filepath,
            timestamp: new Date().toLocaleString('id-ID'),
            caption: viewOnceContent[mediaType].caption || '',
            viewCount: 0
        };

        const mediaId = Date.now().toString();
        viewOnceMedia.set(mediaId, mediaInfo);

        console.log(`üì∏ View Once media disimpan: ${filename}`);

        setTimeout(() => {
            if (fs.existsSync(filepath)) {
                fs.unlinkSync(filepath);
                viewOnceMedia.delete(mediaId);
                console.log(`üóëÔ∏è View Once media dihapus: ${filename}`);
            }
        }, 3600000);

        return mediaId;
    } catch (error) {
        console.error('Error menyimpan view once media:', error);
        return null;
    }
}

// ==================== FUNGSI UTAMA GENERATE GAMBAR ====================
async function generateIQCImage(text, options = {}) {
    try {
        const {
            chatTime = new Date().toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit' }),
            statusBarTime = new Date().toLocaleTimeString('id-ID', { hour: '2-digit', minute: '2-digit' }),
            signalName = 'XL',
            bubbleColor = '#272A2F',
            menuColor = '#272A2F',
            textColor = '#FFFFFF',
            fontName = 'Arial',
            apikey = 'freeApikey'
        } = options;

        const params = new URLSearchParams({
            text,
            chatTime,
            statusBarTime,
            signalName,
            bubbleColor,
            menuColor,
            textColor,
            fontName,
            apikey
        });

        const apiUrl = `https://anabot.my.id/api/maker/iqc?${params.toString()}`;
        console.log(`üñºÔ∏è Generating IQC for text: "${text.substring(0, 50)}..."`);

        const response = await axios.get(apiUrl, {
            responseType: 'arraybuffer',
            timeout: 25000,
            headers: {
                'User-Agent': 'Mozilla/5.0',
                'Accept': 'image/*'
            }
        });

        if (!response.data || response.data.byteLength === 0) throw new Error('Empty response from API.');

        const imageBuffer = Buffer.from(response.data);
        const optimized = await sharp(imageBuffer)
            .jpeg({ quality: 95, chromaSubsampling: '4:4:4' })
            .toBuffer();

        return { image: optimized, size: optimized.length };
    } catch (err) {
        console.error('IQC Error:', err);
        throw new Error(`Gagal membuat gambar IQC: ${err.message}`);
    }
}

// ==================== HANDLER PERINTAH IQC ====================
async function handleIQCImage(sock, jid, msg, args, pushName, originalMsg) {
    if (args.length < 1) {
        return await sock.sendMessage(jid, {
            text:
`IQC ‚Äî Instagram Quote Creator

Buat gambar quote ala chat WhatsApp.

Contoh:
.iqc Hidup hanya sekali
.iqc -time 19:30 -color blue Jangan menyerah
Reply pesan + .iqc

Opsi:
‚Ä¢ -time HH:MM
‚Ä¢ -signal nama
‚Ä¢ -color blue|green|red|purple|pink|dark|light
‚Ä¢ -font Arial|Helvetica|Times|Courier
‚Ä¢ -textcolor white|black|blue|green|red`
        }, { quoted: originalMsg });
    }

    let quoteText = '';
    let options = {};
    const isReply = msg.message?.extendedTextMessage?.contextInfo?.quotedMessage;
    const parsedArgs = [];

    for (let i = 0; i < args.length; i++) {
        const arg = args[i];
        if (arg.startsWith('-')) {
            const key = arg.toLowerCase();
            const value = args[i + 1];
            switch (key) {
                case '-time':
                    if (value && /^\d{1,2}:\d{2}$/.test(value)) {
                        options.chatTime = value;
                        options.statusBarTime = value;
                        i++;
                    }
                    break;
                case '-signal':
                    if (value) {
                        options.signalName = value;
                        i++;
                    }
                    break;
                case '-color':
                    if (value) {
                        const colors = {
                            blue: '#1E3A8A', green: '#065F46', red: '#7F1D1D',
                            purple: '#4C1D95', pink: '#831843', dark: '#272A2F', light: '#F3F4F6'
                        };
                        options.bubbleColor = colors[value] || '#272A2F';
                        options.menuColor = colors[value] || '#272A2F';
                        i++;
                    }
                    break;
                case '-font':
                    if (value) {
                        const fonts = ['Arial', 'Helvetica', 'Times New Roman', 'Courier New'];
                        options.fontName = fonts.includes(value) ? value : 'Arial';
                        i++;
                    }
                    break;
                case '-textcolor':
                    if (value) {
                        const map = {
                            white: '#FFFFFF', black: '#000000', blue: '#1E3A8A', green: '#065F46', red: '#DC2626'
                        };
                        options.textColor = map[value] || '#FFFFFF';
                        i++;
                    }
                    break;
            }
        } else {
            parsedArgs.push(arg);
        }
    }

    if (isReply) {
        const quoted = msg.message.extendedTextMessage.contextInfo.quotedMessage;
        if (quoted.conversation) quoteText = quoted.conversation;
        else if (quoted.extendedTextMessage?.text) quoteText = quoted.extendedTextMessage.text;
        if (parsedArgs.length > 0) quoteText += ' ' + parsedArgs.join(' ');
    } else {
        quoteText = parsedArgs.join(' ');
    }

    if (!quoteText.trim()) return await sock.sendMessage(jid, { text: 'Teks tidak boleh kosong.' }, { quoted: originalMsg });
    if (quoteText.length > 300) quoteText = quoteText.substring(0, 300);

    const iqc = await generateIQCImage(quoteText, options);

    await sock.sendMessage(jid, {
        image: iqc.image,
        caption:
`"${quoteText.substring(0, 150)}${quoteText.length > 150 ? '...' : ''}"

Dibuat oleh: ${pushName}
Waktu: ${options.chatTime || 'Auto'}
Signal: ${options.signalName || 'XL'}
Ukuran: ${(iqc.size / 1024).toFixed(2)} KB`,
        quoted: originalMsg
    });
}

// ==================== DEMO HANDLER (JIKA MAU TAMBAH) ====================
async function handleIQCDemo(sock, jid, msg, args, pushName, originalMsg) {
    const demoQuotes = [
        "Kamu adalah versi terbaik dari dirimu sendiri.",
        "Jangan pernah berhenti bermimpi.",
        "Setiap hari adalah kesempatan baru.",
        "Percaya pada proses dan nikmati perjalanannya."
    ];
    const randomQuote = demoQuotes[Math.floor(Math.random() * demoQuotes.length)];
    const demoOptions = {
        chatTime: '19:30',
        signalName: 'Telkomsel',
        bubbleColor: '#1E3A8A',
        menuColor: '#1E3A8A',
        textColor: '#FFFFFF',
        fontName: 'Arial'
    };
    const iqc = await generateIQCImage(randomQuote, demoOptions);
    await sock.sendMessage(jid, {
        image: iqc.image,
        caption:
`"${randomQuote}"

Demo IQC ‚Äî Telkomsel 19:30 (Blue theme)`
    }, { quoted: originalMsg });
}

// ==================== FITUR GANTI PROFILE PICTURE BOT ====================
async function handleGantiPP(sock, jid, msg, args, pushName, originalMsg) {
    const hasImage = msg.message?.imageMessage || 
                    (msg.message?.extendedTextMessage?.contextInfo?.quotedMessage?.imageMessage);

    if (!hasImage) {
        await sendReplyWithReaction(sock, jid,
            `üñºÔ∏è *GANTI PROFILE PICTURE BOT* üñºÔ∏è\n\n` +
            `Ubah foto profil bot dengan gambar yang kamu kirim!\n\n` +
            `üìù *Cara Pakai:*\n` +
            `1. Kirim gambar yang ingin dijadikan PP bot\n` +
            `2. Reply gambar tersebut\n` +
            `3. Ketik *.gantipp*\n\n` +
            `‚ö†Ô∏è *Persyaratan:*\n` +
            `‚Ä¢ Hanya owner yang bisa menggunakan fitur ini\n` +
            `‚Ä¢ Ukuran gambar maksimal 5MB\n` +
            `‚Ä¢ Format: JPG, PNG, WEBP\n\n` +
            `üëë *Owner Only:* @6283115105784`,
            originalMsg
        );
        return;
    }

    const sender = msg.key.participant || jid;
    const ownerNumber = '6283115105784@s.whatsapp.net';
    
    if (!sender.includes(ownerNumber.replace('@s.whatsapp.net', ''))) {
        await sendReplyWithReaction(sock, jid,
            `‚ùå *AKSES DITOLAK* ‚ùå\n\n` +
            `Fitur ini hanya untuk owner bot!\n\n` +
            `üëë Owner: Adit (@6283115105784)\n` +
            `üë§ Hubungi owner untuk informasi lebih lanjut.`,
            originalMsg
        );
        return;
    }

    await processCommandWithReaction(sock, jid, originalMsg, 'GANTI_PP', async () => {
        let imageBuffer;
        
        if (msg.message?.extendedTextMessage?.contextInfo?.quotedMessage?.imageMessage) {
            const quotedMsg = {
                key: { remoteJid: jid },
                message: msg.message.extendedTextMessage.contextInfo.quotedMessage
            };
            imageBuffer = await downloadMediaMessage(quotedMsg, "buffer", {});
        } else {
            imageBuffer = await downloadMediaMessage(msg, "buffer", {});
        }

        if (!imageBuffer || imageBuffer.length === 0) {
            throw new Error('Gagal mengambil gambar. Coba dengan gambar yang berbeda.');
        }

        if (imageBuffer.length > 5 * 1024 * 1024) {
            throw new Error("Gambar terlalu besar! Maksimal 5MB.");
        }

        const fileType = await fileTypeFromBuffer(imageBuffer);
        if (!fileType || !['jpg', 'jpeg', 'png', 'webp'].includes(fileType.ext)) {
            throw new Error("Format gambar tidak didukung! Gunakan JPG, PNG, atau WEBP.");
        }

        console.log(`üñºÔ∏è Mengganti profile picture bot...`);

        await sock.updateProfilePicture(sock.user.id, imageBuffer);

        await sendReply(sock, jid,
            `‚úÖ *PROFILE PICTURE BERHASIL DIGANTI!* ‚úÖ\n\n` +
            `üë§ Diubah oleh: ${pushName}\n` +
            `‚è∞ Waktu: ${new Date().toLocaleString('id-ID')}\n` +
            `üñºÔ∏è Format: ${fileType.ext.toUpperCase()}\n` +
            `üìä Ukuran: ${(imageBuffer.length / 1024).toFixed(2)} KB\n\n` +
            `üèÜ Profile picture bot telah diperbarui!`,
            originalMsg
        );

        await sock.sendMessage(jid, {
            image: imageBuffer,
            caption: `üñºÔ∏è *PREVIEW PP BOT BARU*\n\nIni adalah profile picture bot yang baru!`,
            ...createReplyContext(originalMsg)
        }).catch(error => {
            console.error('Error sending preview:', error);
        });
    });
}

// ==================== FITUR LIHAT PP BOT ====================
async function handleLihatPP(sock, jid, msg, args, pushName, originalMsg) {
    await processCommandWithReaction(sock, jid, originalMsg, 'LIHAT_PP', async () => {
        const profilePictureUrl = await sock.profilePictureUrl(sock.user.id, 'image');
        
        if (!profilePictureUrl) {
            await sendReply(sock, jid,
                `üñºÔ∏è *PROFILE PICTURE BOT*\n\n` +
                `Bot saat ini tidak memiliki profile picture.\n\n` +
                `Gunakan *.gantipp* untuk mengatur PP bot.`,
                originalMsg
            );
            return;
        }

        const response = await axios.get(profilePictureUrl, { responseType: 'arraybuffer' });
        const imageBuffer = Buffer.from(response.data);

        await sock.sendMessage(jid, {
            image: imageBuffer,
            caption: `üñºÔ∏è *PROFILE PICTURE BOT VIOLATION X*\n\n` +
                    `üë§ Nama Bot: Violation X\n` +
                    `üëë Owner: Adit (@6283115105784)\n` +
                    `‚è∞ Last Update: ${new Date().toLocaleString('id-ID')}\n\n` +
                    `üí° Gunakan *.gantipp* untuk mengganti PP bot\n` +
                    `‚ö†Ô∏è Hanya owner yang bisa mengganti PP`,
            ...createReplyContext(originalMsg)
        }).catch(error => {
            console.error('Error sending PP:', error);
            throw error;
        });
    });
}

// ==================== FITUR YOUTUBE DOWNLOADER ====================
async function downloadYouTube(url, type = 'audio') {
    return new Promise((resolve, reject) => {
        try {
            const ext = type === 'audio' ? 'mp3' : 'mp4';
            const filename = `${Date.now()}_yt.${ext}`;
            const filepath = path.join(tempDir, filename);

            const baseFlags = '--no-check-certificate --geo-bypass --no-warnings --ignore-errors --socket-timeout 15';
            const cmd = type === 'audio'
                ? `yt-dlp ${baseFlags} -f bestaudio --extract-audio --audio-format mp3 -o "${filepath}" "${url}"`
                : `yt-dlp ${baseFlags} -f bestvideo+bestaudio --merge-output-format mp4 -o "${filepath}" "${url}"`;

            console.log(`üé¨ [YT-DLP] Downloading: ${url}`);

            exec(cmd, { timeout: 90000 }, (err, stdout, stderr) => {
                if (err) {
                    console.error(stderr || err.message);
                    return reject(new Error(`Gagal download video/audio dari YouTube.\n${stderr || err.message}`));
                }

                if (!fs.existsSync(filepath)) {
                    return reject(new Error('File hasil download tidak ditemukan.'));
                }

                resolve({
                    filepath,
                    filename,
                    title: path.basename(filename, `.${ext}`),
                    type,
                    size: fs.statSync(filepath).size
                });
            });
        } catch (error) {
            reject(error);
        }
    });
}

async function searchAndDownloadMusic(query, type = 'audio') {
    try {
        const search = await yts(query);
        if (!search.videos.length) throw new Error('Lagu tidak ditemukan.');

        const video = search.videos[0];
        console.log(`üéµ [SEARCH] Menemukan: ${video.title}`);

        const result = await downloadYouTube(video.url, type);
        result.thumbnail = video.thumbnail;
        result.title = video.title;
        result.url = video.url;
        result.author = video.author.name;
        result.duration = video.timestamp;

        return result;
    } catch (err) {
        throw new Error(`‚ùå Error mencari musik: ${err.message}`);
    }
}

async function handlePlayMusic(sock, jid, msg, args, pushName, originalMsg) {
    if (args.length < 1) {
        await sendReplyWithReaction(sock, jid,
            `üéµ *PLAY MUSIK* üéµ\n\n` +
            `Download musik dari YouTube berdasarkan judul.\n\n` +
            `üìå *Format:* .play [judul lagu]\n\n` +
            `üí° *Contoh:*\n` +
            `.play Shape of You\n` +
            `.play Coldplay Adventure of a Lifetime\n` +
            `.play lagu terbaru 2024`,
            originalMsg
        );
        return;
    }

    const query = args.join(' ');

    await processCommandWithReaction(sock, jid, originalMsg, 'PLAY_MUSIC', async () => {
        const result = await searchAndDownloadMusic(query, 'audio');
        
        if (!result || !result.filepath) {
            throw new Error('Gagal mendownload musik');
        }

        if (result.size > 15 * 1024 * 1024) {
            await sendReply(sock, jid,
                `‚öôÔ∏è File terlalu besar (${formatFileSize(result.size)}), mengkompres...`,
                originalMsg
            );
            
            const compressedPath = path.join(tempDir, `compressed_${Date.now()}.mp3`);
            await new Promise((resolve, reject) => {
                ffmpeg(result.filepath)
                    .audioBitrate('128k')
                    .toFormat('mp3')
                    .on('end', resolve)
                    .on('error', reject)
                    .save(compressedPath);
            });
            
            fs.unlinkSync(result.filepath);
            result.filepath = compressedPath;
            result.size = fs.statSync(compressedPath).size;
        }

        const audioBuffer = fs.readFileSync(result.filepath);

        await sock.sendMessage(jid, {
            audio: audioBuffer,
            mimetype: 'audio/mpeg',
            ptt: false,
            fileName: `${result.title}.mp3`,
            caption: `üéµ *${result.title}*\nüë§ ${result.author}\n‚è±Ô∏è ${result.duration}\n‚¨áÔ∏è ${formatFileSize(result.size)}`,
            ...createReplyContext(originalMsg)
        }).catch(error => {
            console.error('Error sending audio:', error);
            throw error;
        });

        setTimeout(() => {
            if (fs.existsSync(result.filepath)) {
                fs.unlinkSync(result.filepath);
            }
        }, 30000);
    });
}

async function handleYoutubeVideo(sock, jid, msg, args, pushName, originalMsg) {
    if (args.length < 1) {
        await sendReplyWithReaction(sock, jid,
            `üé¨ *YOUTUBE DOWNLOADER* üé¨\n\n` +
            `Download video dari YouTube.\n\n` +
            `üìå *Format:* .yt [url_youtube]\n\n` +
            `üí° *Contoh:*\n` +
            `.yt https://youtube.com/watch?v=xxx\n` +
            `.yt https://youtu.be/xxx`,
            originalMsg
        );
        return;
    }

    const url = args[0];
    
    if (!url.includes('youtube.com') && !url.includes('youtu.be')) {
        await sendReplyWithReaction(sock, jid, '‚ùå Bukan URL YouTube yang valid!', originalMsg);
        return;
    }

    await processCommandWithReaction(sock, jid, originalMsg, 'YOUTUBE_DOWNLOAD', async () => {
        const result = await downloadYouTube(url, 'video');
        
        if (!result || !result.filepath) {
            throw new Error('Gagal mendownload video');
        }

        if (result.size > 50 * 1024 * 1024) {
            await sendReply(sock, jid,
                `‚öôÔ∏è Video besar (${formatFileSize(result.size)}), mengkompres...`,
                originalMsg
            );
            
            const compressedPath = path.join(tempDir, `compressed_${Date.now()}.mp4`);
            await new Promise((resolve, reject) => {
                ffmpeg(result.filepath)
                    .videoCodec('libx264')
                    .audioCodec('aac')
                    .size('720x?')
                    .on('end', resolve)
                    .on('error', reject)
                    .save(compressedPath);
            });
            
            fs.unlinkSync(result.filepath);
            result.filepath = compressedPath;
            result.size = fs.statSync(compressedPath).size;
        }

        const videoBuffer = fs.readFileSync(result.filepath);

        await sock.sendMessage(jid, {
            video: videoBuffer,
            caption: `üé¨ *${result.title}*\n‚¨áÔ∏è ${formatFileSize(result.size)}\n‚è±Ô∏è Durasi: ${result.duration}`,
            ...createReplyContext(originalMsg)
        }).catch(error => {
            console.error('Error sending video:', error);
            throw error;
        });

        setTimeout(() => {
            if (fs.existsSync(result.filepath)) {
                fs.unlinkSync(result.filepath);
            }
        }, 30000);
    });
}

// ==================== TIKTOK MULTI-FORMAT DOWNLOADER (CLEAN) ====================
async function downloadTikTokMulti(url) {
    let cleanUrl = url;

    try {
        // Resolve short URL
        if (/vm\.tiktok\.com|vt\.tiktok\.com/.test(url)) {
            try {
                const res = await axios.get(url, {
                    maxRedirects: 5,
                    timeout: 15000,
                    headers: { 'User-Agent': 'Mozilla/5.0' }
                });
                cleanUrl = res.request.res.responseUrl || url;
            } catch {}
        }

        const apiList = [
            `https://api.tiklydown.eu.org/api/download?url=${encodeURIComponent(cleanUrl)}`,
            `https://www.tikwm.com/api/?url=${encodeURIComponent(cleanUrl)}`,
            `https://tikdown.org/api/ajaxSearch`
        ];

        for (const api of apiList) {
            try {
                let response, data;

                if (api.includes('tikdown.org')) {
                    response = await axios.post(
                        api,
                        `q=${encodeURIComponent(cleanUrl)}&lang=en`,
                        {
                            headers: {
                                'Content-Type': 'application/x-www-form-urlencoded',
                                'User-Agent': 'Mozilla/5.0',
                                'Referer': 'https://tikdown.org'
                            },
                            timeout: 30000
                        }
                    );
                    data = response.data;
                } else {
                    response = await axios.get(api, {
                        headers: { 'User-Agent': 'Mozilla/5.0' },
                        timeout: 30000
                    });
                    data = response.data;
                }

                let title = 'TikTok';
                let author = 'Unknown';
                let duration = 'Unknown';
                let uploadTime = 'Unknown';
                let mediaUrl = null;
                let images = [];

                // PHOTO / SLIDESHOW
                const imageData =
                    data.images ||
                    data.data?.images ||
                    [];

                if (Array.isArray(imageData) && imageData.length > 0) {
                    for (let i = 0; i < Math.min(imageData.length, 10); i++) {
                        let img = imageData[i];
                        if (typeof img === 'string') {
                            if (img.startsWith('//')) img = `https:${img}`;
                            else if (!img.startsWith('http')) img = `https://www.tikwm.com${img}`;
                            images.push(img);
                        }
                    }

                    title = data.title || data.data?.title || title;
                    author =
                        data.author?.nickname ||
                        data.data?.author?.nickname ||
                        data.author ||
                        data.data?.author ||
                        author;

                    uploadTime = calculateTimeAgo(
                        data.create_time ||
                        data.data?.create_time ||
                        data.timestamp
                    );

                    const downloaded = [];
                    for (let i = 0; i < images.length; i++) {
                        const filename = `${Date.now()}_tt_img_${i + 1}.jpg`;
                        const filepath = path.join(tempDir, filename);

                        const imgRes = await axios.get(images[i], {
                            responseType: 'stream',
                            timeout: 20000,
                            headers: { 'User-Agent': 'Mozilla/5.0' }
                        });

                        await new Promise((resolve, reject) => {
                            const writer = fs.createWriteStream(filepath);
                            imgRes.data.pipe(writer);
                            writer.on('finish', resolve);
                            writer.on('error', reject);
                        });

                        downloaded.push({ filepath, filename });
                    }

                    if (downloaded.length) {
                        return {
                            type: 'photos',
                            images: downloaded,
                            title,
                            author,
                            duration,
                            uploadTime,
                            count: downloaded.length,
                            source: 'api',
                            url: cleanUrl
                        };
                    }
                }

                // VIDEO
                mediaUrl =
                    data.video_url ||
                    data.data?.hdplay ||
                    data.data?.play ||
                    data.downloadUrl ||
                    null;

                if (mediaUrl) {
                    if (mediaUrl.startsWith('//')) mediaUrl = `https:${mediaUrl}`;
                    if (!mediaUrl.startsWith('http')) mediaUrl = `https://www.tikwm.com${mediaUrl}`;

                    title = data.title || data.data?.title || title;
                    author =
                        data.author?.nickname ||
                        data.data?.author?.nickname ||
                        data.author ||
                        data.data?.author ||
                        author;

                    duration = data.duration || data.data?.duration || duration;
                    uploadTime = calculateTimeAgo(
                        data.create_time ||
                        data.data?.create_time ||
                        data.timestamp
                    );

                    const filename = `${Date.now()}_tiktok.mp4`;
                    const filepath = path.join(tempDir, filename);

                    const videoRes = await axios.get(mediaUrl, {
                        responseType: 'stream',
                        timeout: 60000,
                        headers: {
                            'User-Agent': 'Mozilla/5.0',
                            'Referer': 'https://www.tiktok.com'
                        }
                    });

                    await new Promise((resolve, reject) => {
                        const writer = fs.createWriteStream(filepath);
                        videoRes.data.pipe(writer);
                        writer.on('finish', resolve);
                        writer.on('error', reject);
                    });

                    const stats = fs.statSync(filepath);

                    return {
                        type: 'video',
                        filepath,
                        filename,
                        title,
                        author,
                        duration,
                        uploadTime,
                        size: stats.size,
                        quality: 'HD',
                        source: 'api',
                        url: cleanUrl
                    };
                }

            } catch {
                continue;
            }
        }

        // FINAL FALLBACK
        return await downloadTikTokWithYtDlp(cleanUrl);

    } catch {
        return await downloadTikTokWithYtDlp(url);
    }
}

async function downloadTikTokWithYtDlp(url) {
    return new Promise((resolve, reject) => {
        try {
            const filename = `${Date.now()}_tiktok_ytdlp.mp4`;
            const filepath = path.join(tempDir, filename);

            const baseFlags = '--no-check-certificate --geo-bypass --no-warnings --ignore-errors --socket-timeout 15';
            const cmd = `yt-dlp ${baseFlags} -f "best[height<=720]" --merge-output-format mp4 -o "${filepath}" "${url}"`;

            console.log(`üé¨ [YT-DLP-TikTok] Downloading: ${url}`);
            console.log(`üìå Command: ${cmd}`);

            exec(cmd, { timeout: 120000 }, async (err, stdout, stderr) => {
                if (err) {
                    console.error('YT-DLP Error:', stderr || err.message);
                    
                    try {
                        console.log('üîß Mencoba format fallback...');
                        const fallbackCmd = `yt-dlp ${baseFlags} -f "best" --merge-output-format mp4 -o "${filepath}" "${url}"`;
                        
                        exec(fallbackCmd, { timeout: 120000 }, async (fallbackErr, fallbackStdout, fallbackStderr) => {
                            if (fallbackErr) {
                                console.error('YT-DLP Fallback Error:', fallbackStderr || fallbackErr.message);
                                return reject(new Error(`Gagal download TikTok dengan yt-dlp.\nError: ${fallbackStderr || fallbackErr.message}`));
                            }

                            if (!fs.existsSync(filepath)) {
                                return reject(new Error('File hasil download tidak ditemukan.'));
                            }

                            try {
                                const infoCmd = `yt-dlp --dump-json "${url}"`;
                                console.log(`üìÑ Getting video info: ${infoCmd}`);
                                const infoOutput = execSync(infoCmd, { timeout: 30000 }).toString();
                                const videoInfo = JSON.parse(infoOutput);

                                const stats = fs.statSync(filepath);
                                resolve({
                                    type: 'video',
                                    filepath,
                                    filename,
                                    title: videoInfo.title || 'TikTok Video',
                                    author: videoInfo.uploader || videoInfo.channel || 'Unknown Creator',
                                    duration: formatDuration(videoInfo.duration) || 'Unknown',
                                    uploadTime: calculateTimeAgo(videoInfo.upload_date) || 'Unknown',
                                    size: stats.size,
                                    quality: 'HD',
                                    source: 'yt-dlp'
                                });
                            } catch (infoError) {
                                console.log('‚ö†Ô∏è Gagal mendapatkan info video:', infoError.message);
                                const stats = fs.statSync(filepath);
                                resolve({
                                    type: 'video',
                                    filepath,
                                    filename,
                                    title: 'TikTok Video',
                                    author: 'Unknown Creator',
                                    duration: 'Unknown',
                                    uploadTime: 'Unknown',
                                    size: stats.size,
                                    quality: 'HD',
                                    source: 'yt-dlp'
                                });
                            }
                        });
                    } catch (finalError) {
                        reject(new Error(`Semua metode download TikTok gagal: ${finalError.message}`));
                    }
                    return;
                }

                if (!fs.existsSync(filepath)) {
                    return reject(new Error('File hasil download tidak ditemukan.'));
                }

                try {
                    const infoCmd = `yt-dlp --dump-json "${url}"`;
                    console.log(`üìÑ Getting video info: ${infoCmd}`);
                    const infoOutput = execSync(infoCmd, { timeout: 30000 }).toString();
                    const videoInfo = JSON.parse(infoOutput);

                    const stats = fs.statSync(filepath);
                    resolve({
                        type: 'video',
                        filepath,
                        filename,
                        title: videoInfo.title || 'TikTok Video',
                        author: videoInfo.uploader || videoInfo.channel || 'Unknown Creator',
                        duration: formatDuration(videoInfo.duration) || 'Unknown',
                        uploadTime: calculateTimeAgo(videoInfo.upload_date) || 'Unknown',
                        size: stats.size,
                        quality: 'HD',
                        source: 'yt-dlp'
                    });
                } catch (infoError) {
                    console.log('‚ö†Ô∏è Gagal mendapatkan info video:', infoError.message);
                    const stats = fs.statSync(filepath);
                    resolve({
                        type: 'video',
                        filepath,
                        filename,
                        title: 'TikTok Video',
                        author: 'Unknown Creator',
                        duration: 'Unknown',
                        uploadTime: 'Unknown',
                        size: stats.size,
                        quality: 'HD',
                        source: 'yt-dlp'
                    });
                }
            });
        } catch (error) {
            reject(error);
        }
    });
}

async function handleTikTokMulti(sock, jid, msg, args, pushName, originalMsg) {
    if (args.length < 1) {
        await sendReplyWithReaction(sock, jid,
            `üéµ *TIKTOK DOWNLOADER* üéµ\n\n` +
            `Download video atau foto dari TikTok otomatis!\n\n` +
            `üë§ *Format:* .tiktok <link_tiktok>\n\n` +
            `üìù *Contoh:*\n` +
            `.tiktok https://vt.tiktok.com/xxx\n` +
            `.tiktok https://www.tiktok.com/@user/video/123\n` +
            `.tiktok https://vm.tiktok.com/xyz\n\n` +
            `üí° *Fitur:*\n` +
            `‚Ä¢ Auto detect video/foto\n` +
            `‚Ä¢ Support slideshow (multiple photos)\n` +
            `‚Ä¢ Kualitas HD\n` +
            `‚Ä¢ Info lengkap\n\n` +
            `‚ö†Ô∏è *Note:* Maksimal 10 foto per slideshow`,
            originalMsg
        );
        return;
    }

    const tiktokUrl = args[0];
    
    if (!tiktokUrl.includes('tiktok.com')) {
        await sendReplyWithReaction(sock, jid, '‚ùå Bukan link TikTok yang valid!', originalMsg);
        return;
    }

    await processCommandWithReaction(sock, jid, originalMsg, 'TIKTOK_DOWNLOAD', async () => {
        const tiktokData = await downloadTikTokMulti(tiktokUrl);

        if (tiktokData.type === 'photos') {
            await sendReply(sock, jid,
                `‚úÖ *TIKTOK PHOTO SLIDESHOW* ‚úÖ\n\n` +
                `üìù Judul: ${tiktokData.title}\n` +
                `üë§ Creator: ${tiktokData.author}\n` +
                `üìä Total Foto: ${tiktokData.count}\n` +
                `üïí Upload: ${tiktokData.uploadTime}\n\n` +
                `‚¨ÜÔ∏è Mengirim ${tiktokData.count} foto...`,
                originalMsg
            );

            for (let i = 0; i < tiktokData.images.length; i++) {
                const image = tiktokData.images[i];
                const imageBuffer = fs.readFileSync(image.filepath);
                
                await sock.sendMessage(jid, {
                    image: imageBuffer,
                    caption: `üñºÔ∏è *TikTok Photo ${i + 1}/${tiktokData.count}*\n\n` +
                            `üìù ${tiktokData.title}\n` +
                            `üë§ ${tiktokData.author}\n` +
                            `‚è∞ ${new Date().toLocaleString('id-ID')}`,
                    ...createReplyContext(originalMsg)
                }).catch(error => {
                    console.error(`Error sending photo ${i + 1}:`, error);
                });

                if (i < tiktokData.images.length - 1) {
                    await delay(2000 + Math.random() * 1000);
                }

                setTimeout(() => {
                    if (fs.existsSync(image.filepath)) {
                        fs.unlinkSync(image.filepath);
                    }
                }, 30000);
            }

        } else if (tiktokData.type === 'video') {
            const videoBuffer = fs.readFileSync(tiktokData.filepath);
            const fileSize = formatFileSize(tiktokData.size);

            await sendReply(sock, jid,
                `‚úÖ *TIKTOK VIDEO BERHASIL* ‚úÖ\n\n` +
                `üìù Judul: ${tiktokData.title}\n` +
                `üë§ Creator: ${tiktokData.author}\n` +
                `‚è±Ô∏è Durasi: ${tiktokData.duration}\n` +
                `üíæ Ukuran: ${fileSize}\n` +
                `üé¨ Kualitas: ${tiktokData.quality}\n` +
                `üïí Upload: ${tiktokData.uploadTime}\n\n` +
                `‚¨ÜÔ∏è Mengirim video...`,
                originalMsg
            );

            await sock.sendMessage(jid, {
                video: videoBuffer,
                caption: `üé¨ *TIKTOK VIDEO*\n\n` +
                        `üìù ${tiktokData.title}\n` +
                        `üë§ ${tiktokData.author}\n` +
                        `‚è±Ô∏è ${tiktokData.duration} | ${fileSize}\n` +
                        `üïí ${tiktokData.uploadTime}\n\n` +
                        `‚¨áÔ∏è Download via Bot`,
                ...createReplyContext(originalMsg)
            }).catch(error => {
                console.error('Error sending TikTok video:', error);
                throw error;
            });

            setTimeout(() => {
                if (fs.existsSync(tiktokData.filepath)) {
                    fs.unlinkSync(tiktokData.filepath);
                }
            }, 30000);

        } else {
            throw new Error('Format media tidak dikenali');
        }
    });
}

// ==================== FITUR CUACA ====================
async function getWeather(location) {
    try {
        if (!OPENWEATHER_API_KEY) {
            return '‚ùå API key OpenWeather belum diset. Tambahkan OPENWEATHER_API_KEY di environment variables.';
        }

        const response = await axios.get(`https://api.openweathermap.org/data/2.5/weather?q=${encodeURIComponent(location)}&appid=${OPENWEATHER_API_KEY}&units=metric&lang=id`);
        const data = response.data;

        return `üå§Ô∏è *Cuaca di ${data.name}*
        
üå°Ô∏è Suhu: ${data.main.temp}¬∞C (Terasa: ${data.main.feels_like}¬∞C)
üìä Kelembaban: ${data.main.humidity}%
üí® Angin: ${data.wind.speed} m/s
üå´Ô∏è Kondisi: ${data.weather[0].description}
üëÅÔ∏è Jarak Pandang: ${data.visibility} meter

üìç Koordinat: 
   - Latitude: ${data.coord.lat}
   - Longitude: ${data.coord.lon}`;
    } catch (error) {
        if (error.response && error.response.status === 404) {
            return '‚ùå Lokasi tidak ditemukan. Coba dengan nama kota yang lebih spesifik.';
        }
        return `‚ùå Gagal mendapatkan info cuaca: ${error.message}`;
    }
}

async function handleCuaca(sock, jid, msg, args, pushName, originalMsg) {
    if (args.length < 1) {
        await sendReplyWithReaction(sock, jid,
            `üå§Ô∏è *INFO CUACA* üå§Ô∏è\n\n` +
            `Dapatkan informasi cuaca terkini.\n\n` +
            `üìå *Format:* .cuaca [nama_kota]\n\n` +
            `üí° *Contoh:*\n` +
            `.cuaca Jakarta\n` +
            `.cuaca Bandung\n` +
            `.cuaca Surabaya`,
            originalMsg
        );
        return;
    }

    const location = args.join(' ');

    await processCommandWithReaction(sock, jid, originalMsg, 'CUACA', async () => {
        const weatherInfo = await getWeather(location);
        await sendReply(sock, jid, weatherInfo, originalMsg);
    });
}

// ==================== FITUR SCRIPT ROBLOX ALL IN ONE ====================
const robloxScripts = {
    'fishit': [
        {
            name: "üêü Chloe X - Fish It",
            code: 'loadstring(game:HttpGet("https://raw.githubusercontent.com/MajestySkie/Chloe-X/main/Main/ChloeX"))()',
            description: "Script Chloe X untuk game Fish It - Auto Farm, Auto Fish, dll"
        },
        {
            name: "üêü Sora Hub - Fish It", 
            code: 'loadstring(game:HttpGet("https://raw.githubusercontent.com/elainaceles/SoraHub/refs/heads/main/Fishit.lua"))()',
            description: "Sora Hub script untuk Fish It - GUI Modern"
        },
        {
            name: "üêü Free Loader - Fish It",
            code: 'loadstring(game:HttpGet("https://raw.githubusercontent.com/x2zu/loader/main/freeloader.lua", true))()',
            description: "Free Loader untuk Fish It - No Key"
        }
    ],
    
    'bloxfruit': [
        {
            name: "üçé Hoho Hub - Blox Fruit",
            code: 'loadstring(game:HttpGet("https://raw.githubusercontent.com/acsu123/HOHO_H/main/Loading_UI"))()',
            description: "Hoho Hub untuk Blox Fruit - Auto Farm, Auto Raid"
        },
        {
            name: "üçé V.G Hub - Blox Fruit",
            code: 'loadstring(game:HttpGet("https://raw.githubusercontent.com/1201for/V.G-Hub/main/V.Ghub"))()',
            description: "V.G Hub untuk Blox Fruit - All Features"
        },
        {
            name: "üçé Zen X - Blox Fruit", 
            code: 'loadstring(game:HttpGet("https://raw.githubusercontent.com/Kaizenofficiall/ZenX/main/Loader"))()',
            description: "Zen X script untuk Blox Fruit - OP Features"
        }
    ],

    'bladeball': [
        {
            name: "‚öîÔ∏è Project EBB - Blade Ball",
            code: 'loadstring(game:HttpGet("https://projectebb.com/script.lua"))()',
            description: "Project EBB untuk Blade Ball - Auto Parry, Auto Win"
        },
        {
            name: "‚öîÔ∏è Nexus Hub - Blade Ball",
            code: 'loadstring(game:HttpGet("https://raw.githubusercontent.com/NoobHubz/Roblox/main/BladeBall.lua"))()',
            description: "Nexus Hub untuk Blade Ball - All Features"
        }
    ],

    'arsenal': [
        {
            name: "üî´ V.G Hub - Arsenal",
            code: 'loadstring(game:HttpGet("https://raw.githubusercontent.com/1201for/V.G-Hub/main/V.Ghub"))()',
            description: "V.G Hub untuk Arsenal - AimBot, WallHack"
        },
        {
            name: "üî´ Nexus Hub - Arsenal",
            code: 'loadstring(game:HttpGet("https://raw.githubusercontent.com/NoobHubz/Roblox/main/Arsenal.lua"))()',
            description: "Nexus Hub untuk Arsenal - OP Script"
        }
    ],

    'pet simulator': [
        {
            name: "ü¶Ñ V.G Hub - Pet Simulator 99",
            code: 'loadstring(game:HttpGet("https://raw.githubusercontent.com/1201for/V.G-Hub/main/V.Ghub"))()',
            description: "V.G Hub untuk Pet Simulator 99 - Auto Farm"
        },
        {
            name: "ü¶Ñ Auto Farm Pet Simulator",
            code: 'loadstring(game:HttpGet("https://pastebin.com/raw/opqrst"))()',
            description: "Auto Farm untuk Pet Simulator - Fast Hatch"
        }
    ],

    'doors': [
        {
            name: "üö™ V.G Hub - Doors",
            code: 'loadstring(game:HttpGet("https://raw.githubusercontent.com/1201for/V.G-Hub/main/V.Ghub"))()',
            description: "V.G Hub untuk Doors - ESP, Auto Avoid"
        },
        {
            name: "üö™ Nexus Hub - Doors",
            code: 'loadstring(game:HttpGet("https://raw.githubusercontent.com/NoobHubz/Roblox/main/Doors.lua"))()',
            description: "Nexus Hub untuk Doors - All Entities ESP"
        }
    ],

    'universal': [
        {
            name: "üåê Infinite Yield FE",
            code: 'loadstring(game:HttpGet("https://raw.githubusercontent.com/EdgeIY/infiniteyield/master/source"))()',
            description: "Infinite Yield Admin Commands - 200+ Commands"
        },
        {
            name: "üåê CMD-X",
            code: 'loadstring(game:HttpGet("https://raw.githubusercontent.com/CMD-X/CMD-X/master/Source"))()',
            description: "CMD-X Admin Commands - Powerful Admin"
        },
        {
            name: "üåê Dark Dex V4",
            code: 'loadstring(game:HttpGet("https://raw.githubusercontent.com/Babyhamsta/RBLX_Scripts/main/Universal/BypassedDarkDexV3.lua"))()',
            description: "Dark Dex Explorer - Game Explorer"
        },
        {
            name: "üåê Simple Spy",
            code: 'loadstring(game:HttpGet("https://raw.githubusercontent.com/78n/SimpleSpy/main/SimpleSpySource.lua"))()',
            description: "Simple Spy - Remote Spy"
        }
    ]
};

async function handleScriptRoblox(sock, jid, msg, args, pushName, originalMsg) {
    const category = args[0]?.toLowerCase() || 'all';

    if (category === 'list' || category === 'help') {
        const helpText = `üéÆ *SCRIPT ROBLOX HUB* üéÆ

üìù *Cara Penggunaan:*
‚Ä¢ *.sc* - Dapatkan SEMUA script sekaligus
‚Ä¢ *.sc [game]* - Script untuk game tertentu
‚Ä¢ *.sc list* - Lihat daftar game

üë§ *Daftar Game:*
‚Ä¢ fishit - Script Fish It (3 script)
‚Ä¢ bloxfruit - Script Blox Fruit (3 script)  
‚Ä¢ bladeball - Script Blade Ball (2 script)
‚Ä¢ arsenal - Script Arsenal (2 script)
‚Ä¢ pet simulator - Script Pet Simulator (2 script)
‚Ä¢ doors - Script Doors (2 script)
‚Ä¢ universal - Universal Script (4 script)

üí° *Contoh:*
.sc          <- Dapat semua script
.sc fishit   <- Script Fish It saja
.sc universal <- Script universal

‚ö†Ô∏è *Tips:*
- Copy script yang diinginkan
- Paste di executor (Synapse/Krnl)
- Execute dan enjoy!

ü§ñ *Executor Recommended:*
‚Ä¢ Synapse X (Paid)
‚Ä¢ Krnl (Free)
‚Ä¢ Fluxus (Free)
‚Ä¢ Oxygen U (Free)`;

        await sendReplyWithReaction(sock, jid, helpText, originalMsg);
        return;
    }

    if (category === 'all') {
        await processCommandWithReaction(sock, jid, originalMsg, 'SCRIPT_ROBLOX_ALL', async () => {
            await sendReply(sock, jid,
                `üéÆ *ALL ROBLOX SCRIPTS* üéÆ\n\n` +
                `üìä Mengirim ${Object.keys(robloxScripts).length} kategori script...\n` +
                `‚è±Ô∏è Tunggu sebentar, semua script akan dikirim!\n\n` +
                `üë§ Request oleh: ${pushName}\n` +
                `‚è∞ ${new Date().toLocaleString('id-ID')}`,
                originalMsg
            );

            for (const [gameCategory, scripts] of Object.entries(robloxScripts)) {
                let categoryText = `üë§ *${gameCategory.toUpperCase()} SCRIPTS* üë§\n\n`;
                
                scripts.forEach((script, index) => {
                    categoryText += `*${index + 1}. ${script.name}*\n`;
                    categoryText += `üìå ${script.description}\n`;
                    categoryText += `üìã *Code:*\n\`\`\`lua\n${script.code}\n\`\`\`\n\n`;
                });

                categoryText += `üí° *Total: ${scripts.length} script*`;
                
                await sock.sendMessage(jid, { 
                    text: categoryText,
                    ...createReplyContext(originalMsg)
                }).catch(error => {
                    console.error(`Error sending scripts for ${gameCategory}:`, error);
                });

                await delay(2000);
            }

            await sendReply(sock, jid,
                `‚úÖ *SEMUA SCRIPT TELAH DIKIRIM!* ‚úÖ\n\n` +
                `üìä *Total Kategori:* ${Object.keys(robloxScripts).length}\n` +
                `üìã *Total Script:* ${Object.values(robloxScripts).reduce((acc, scripts) => acc + scripts.length, 0)}\n\n` +
                `üí° *Cara Pakai:*\n` +
                `1. Pilih script yang diinginkan\n` +
                `2. Copy code lengkapnya\n` +
                `3. Paste di executor\n` +
                `4. Execute dan enjoy!\n\n` +
                `‚ö†Ô∏è *Gunakan dengan bijak!*\n` +
                `üéÆ *Happy Gaming!*`,
                originalMsg
            );
        });
        return;
    }

    if (!robloxScripts[category]) {
        await sendReplyWithReaction(sock, jid, 
            `‚ùå *KATEGORI TIDAK DITEMUKAN* ‚ùå\n\n` +
            `Kategori "${category}" tidak tersedia.\n\n` +
            `Gunakan *.sc list* untuk melihat daftar kategori.\n` +
            `Atau ketik *.sc* saja untuk dapat semua script.`,
            originalMsg
        );
        return;
    }

    const scripts = robloxScripts[category];
    const scriptIndex = parseInt(args[1]) - 1;

    if (isNaN(scriptIndex) || scriptIndex < 0 || scriptIndex >= scripts.length) {
        await processCommandWithReaction(sock, jid, originalMsg, 'SCRIPT_ROBLOX_CATEGORY', async () => {
            let categoryText = `üéÆ *${category.toUpperCase()} SCRIPTS* üéÆ\n\n`;
            categoryText += `üìù *Daftar Script (${scripts.length}):*\n\n`;
            
            scripts.forEach((script, index) => {
                categoryText += `*${index + 1}. ${script.name}*\n`;
                categoryText += `üìå ${script.description}\n`;
                categoryText += `üìã *Code:*\n\`\`\`lua\n${script.code}\n\`\`\`\n\n`;
            });

            categoryText += `üí° *Gunakan:* .sc ${category} [angka]\n`;
            categoryText += `Contoh: .sc ${category} 1\n\n`;
            categoryText += `ü§ñ *Atau ketik .sc untuk semua script*`;

            await sendReply(sock, jid, categoryText, originalMsg);
        });
        return;
    }

    const selectedScript = scripts[scriptIndex];
    
    await processCommandWithReaction(sock, jid, originalMsg, 'SCRIPT_ROBLOX_SINGLE', async () => {
        await sendReply(sock, jid,
            `üéÆ *${selectedScript.name}* üéÆ\n\n` +
            `üìå *Deskripsi:* ${selectedScript.description}\n\n` +
            `üìã *Script Code:*\n\`\`\`lua\n${selectedScript.code}\n\`\`\`\n\n` +
            `üí° *Cara Pakai:*\n` +
            `1. Copy script di atas\n` +
            `2. Buka Roblox Executor\n` +
            `3. Paste dan Execute\n\n` +
            `üë§ *Script ${scriptIndex + 1} dari ${scripts.length}*\n` +
            `‚ö†Ô∏è *Gunakan dengan bijak!*`,
            originalMsg
        );
    });
}

// ==================== INSTAGRAM DOWNLOADER ====================
async function downloadInstagram(url) {
    try {
        console.log(`üì∏ [Instagram] Processing URL: ${url}`);
        
        let cleanUrl = url.trim();
        if (!cleanUrl.startsWith('http')) {
            cleanUrl = 'https://' + cleanUrl;
        }

        if (!cleanUrl.includes('instagram.com')) {
            throw new Error('Bukan URL Instagram yang valid!');
        }

        const apis = [
            `https://api.yodiw.com/api/v1/instagram?url=${encodeURIComponent(cleanUrl)}`,
            `https://api.hamzanw.xyz/api/download/ig?url=${encodeURIComponent(cleanUrl)}`,
            `https://api.ryzendesu.vip/api/download/ig?url=${encodeURIComponent(cleanUrl)}`,
            `https://rest-api.akuari.my.id/downloader/igd?url=${encodeURIComponent(cleanUrl)}`,
            `https://api.erdwpe.com/api/downloader/ig?url=${encodeURIComponent(cleanUrl)}`
        ];

        let result = null;
        let lastError = null;

        for (const api of apis) {
            try {
                console.log(`üîß Mencoba API: ${api.split('/')[2]}`);
                
                const response = await axios.get(api, {
                    timeout: 30000,
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                        'Accept': 'application/json',
                        'Accept-Language': 'id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7'
                    }
                });

                console.log('üìÑ Response API status:', response.status);
                
                if (response.data && (response.data.status === true || response.data.success === true)) {
                    result = response.data;
                    break;
                } else if (response.data.data) {
                    result = response.data;
                    break;
                } else if (response.data.result) {
                    result = response.data;
                    break;
                }

            } catch (apiError) {
                lastError = apiError;
                console.log(`‚ö†Ô∏è API ${api.split('/')[2]} gagal:`, apiError.message);
                continue;
            }
        }

        if (!result) {
            throw new Error('Semua API gagal, coba lagi nanti');
        }

        console.log('üé≠ Instagram data berhasil didapatkan:', JSON.stringify(result).substring(0, 200) + '...');

        let mediaData = null;
        let author = 'Unknown';
        let caption = 'No caption';
        let likes = 0;
        let comments = 0;
        let timestamp = 'Unknown';
        let type = 'unknown';

        if (result.data && result.data.media) {
            mediaData = result.data;
            author = mediaData.author || result.data.author_name || 'Unknown';
            caption = mediaData.caption || result.data.title || 'No caption';
            type = mediaData.type || 'post';
            timestamp = mediaData.date || 'Unknown';
            likes = mediaData.likes_count || 0;
            comments = mediaData.comments_count || 0;
        }
        else if (result.result) {
            mediaData = result.result;
            author = mediaData.author || 'Unknown';
            caption = mediaData.caption || result.caption || 'No caption';
            type = mediaData.type || (mediaData.url ? 'single' : 'multiple');
            timestamp = mediaData.timestamp || 'Unknown';
            likes = mediaData.likes || 0;
            comments = mediaData.comments || 0;
        }
        else if (result.downloadUrls || result.urls) {
            mediaData = result;
            author = result.author || result.owner || 'Unknown';
            caption = result.caption || 'No caption';
            type = result.media_type || (result.urls && result.urls.length > 1 ? 'multiple' : 'single');
            timestamp = result.taken_at || result.date || 'Unknown';
            likes = result.like_count || result.likes || 0;
            comments = result.comment_count || result.comments || 0;
        }
        else if (result.code === 200 && result.data) {
            mediaData = result.data;
            author = mediaData.author || 'Unknown';
            caption = mediaData.caption || 'No caption';
            type = mediaData.media_type || 'post';
            timestamp = mediaData.timestamp || 'Unknown';
            likes = mediaData.likes || 0;
            comments = mediaData.comments || 0;
        }
        else if (result.respon) {
            mediaData = result.respon;
            author = mediaData.username || 'Unknown';
            caption = mediaData.caption || 'No caption';
            type = mediaData.type || 'post';
            timestamp = mediaData.timestamp || 'Unknown';
            likes = mediaData.like || mediaData.like_count || 0;
            comments = mediaData.comments || 0;
        }
        else {
            mediaData = result;
        }

        let mediaUrls = [];
        
        if (mediaData.downloadUrls) {
            mediaUrls = mediaData.downloadUrls.map(item => item.url);
            type = 'multiple';
        } else if (mediaData.urls) {
            mediaUrls = mediaData.urls;
            type = 'multiple';
        } else if (mediaData.media) {
            mediaUrls = mediaData.media;
            type = 'multiple';
        } else if (mediaData.url) {
            mediaUrls = [mediaData.url];
            type = 'single';
        } else if (mediaData.hd || mediaData.hd_url) {
            mediaUrls = [mediaData.hd || mediaData.hd_url];
            type = 'single';
        } else if (mediaData.thumbnail || mediaData.thumb) {
            mediaUrls = [mediaData.thumbnail || mediaData.thumb];
            type = 'single';
        }

        if (mediaUrls.length === 0 && result.download_link) {
            mediaUrls = [result.download_link];
            type = 'single';
        }

        if (mediaUrls.length === 0) {
            throw new Error('Tidak dapat menemukan link media Instagram');
        }

        console.log(`üìä Instagram type: ${type}, Media count: ${mediaUrls.length}`);

        const downloadedMedia = [];
        
        for (let i = 0; i < Math.min(mediaUrls.length, 10); i++) {
            try {
                const mediaUrl = mediaUrls[i];
                const extension = mediaUrl.includes('.mp4') ? 'mp4' : 
                                 mediaUrl.includes('.jpg') ? 'jpg' : 
                                 mediaUrl.includes('.png') ? 'png' : 'jpg';
                const filename = `${Date.now()}_ig_${i + 1}.${extension}`;
                const filepath = path.join(tempDir, filename);

                console.log(`‚¨áÔ∏è Downloading Instagram media ${i + 1}: ${mediaUrl.substring(0, 100)}...`);
                
                const response = await axios({
                    method: 'GET',
                    url: mediaUrl,
                    responseType: 'stream',
                    timeout: 60000,
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                        'Referer': 'https://www.instagram.com/',
                        'Accept': '*/*',
                        'Accept-Language': 'id-ID,id;q=0.9,en-US;q=0.8,en;q=0.7',
                        'Origin': 'https://www.instagram.com'
                    }
                });

                const writer = fs.createWriteStream(filepath);
                response.data.pipe(writer);

                await new Promise((resolve, reject) => {
                    writer.on('finish', resolve);
                    writer.on('error', reject);
                });

                const stats = fs.statSync(filepath);
                downloadedMedia.push({
                    filepath,
                    filename,
                    url: mediaUrl,
                    size: stats.size,
                    type: extension === 'mp4' ? 'video' : 'image',
                    index: i + 1
                });

                console.log(`‚úÖ Instagram media ${i + 1} downloaded: ${formatFileSize(stats.size)}`);

                if (i < mediaUrls.length - 1) {
                    await delay(1000);
                }

            } catch (downloadError) {
                console.log(`‚ö†Ô∏è Gagal download media ${i + 1}:`, downloadError.message);
            }
        }

        if (downloadedMedia.length === 0) {
            throw new Error('Gagal mendownload semua media Instagram');
        }

        return {
            success: true,
            type: type,
            author: author,
            caption: caption.substring(0, 500),
            likes: likes,
            comments: comments,
            timestamp: timestamp,
            media: downloadedMedia,
            mediaCount: downloadedMedia.length,
            url: cleanUrl,
            source: 'instagram-api'
        };

    } catch (error) {
        console.error('‚ùå Instagram download error:', error);
        throw new Error(`Gagal download Instagram: ${error.message}`);
    }
}

async function handleInstagram(sock, jid, msg, args, pushName, originalMsg) {
    if (args.length < 1) {
        await sendReplyWithReaction(sock, jid,
            `üì∏ *INSTAGRAM DOWNLOADER* üì∏\n\n` +
            `Download foto, video, dan reels dari Instagram!\n\n` +
            `üë§ *Format:* .ig <link_instagram>\n\n` +
            `üìù *Contoh:*\n` +
            `.ig https://instagram.com/p/xxx\n` +
            `.ig https://www.instagram.com/reel/xxx\n` +
            `.ig https://instagram.com/stories/xxx\n` +
            `.ig https://ig.me/p/xxx\n\n` +
            `üí° *Fitur:*\n` +
            `‚Ä¢ Support semua tipe konten\n` +
            `‚Ä¢ Auto detect single/multiple media\n` +
            `‚Ä¢ Kualitas HD\n` +
            `‚Ä¢ Info lengkap (likes, comments, caption)\n\n` +
            `‚ö†Ô∏è *Note:*\n` +
            `‚Ä¢ Maksimal 10 media per post\n` +
            `‚Ä¢ Support private post (tergantung API)\n` +
            `‚Ä¢ Stories hanya untuk 24 jam terakhir`,
            originalMsg
        );
        return;
    }

    const instagramUrl = args[0];
    
    if (!instagramUrl.includes('instagram.com') && !instagramUrl.includes('ig.me')) {
        await sendReplyWithReaction(sock, jid, '‚ùå Bukan link Instagram yang valid!', originalMsg);
        return;
    }

    await processCommandWithReaction(sock, jid, originalMsg, 'INSTAGRAM_DOWNLOAD', async () => {
        const igData = await downloadInstagram(instagramUrl);

        await sendReply(sock, jid,
            `‚úÖ *INSTAGRAM CONTENT DETECTED* ‚úÖ\n\n` +
            `üë§ Author: ${igData.author}\n` +
            `üìù Type: ${igData.type === 'multiple' ? 'Multiple Media' : 'Single Post'}\n` +
            `üìä Media: ${igData.mediaCount} file\n` +
            `‚ù§Ô∏è Likes: ${igData.likes}\n` +
            `üí¨ Comments: ${igData.comments}\n` +
            `üïí Timestamp: ${calculateTimeAgo(igData.timestamp)}\n\n` +
            `üí¨ *Caption:*\n${igData.caption}\n\n` +
            `‚¨ÜÔ∏è Mengirim ${igData.mediaCount} media...`,
            originalMsg
        );

        for (let i = 0; i < igData.media.length; i++) {
            const media = igData.media[i];
            const mediaBuffer = fs.readFileSync(media.filepath);

            if (media.type === 'video') {
                await sock.sendMessage(jid, {
                    video: mediaBuffer,
                    caption: `üé¨ *Instagram Video ${i + 1}/${igData.mediaCount}*\n\n` +
                            `üë§ ${igData.author}\n` +
                            `üìä ${formatFileSize(media.size)}\n` +
                            `‚ù§Ô∏è ${igData.likes} likes\n` +
                            `‚è∞ ${new Date().toLocaleString('id-ID')}`,
                    ...createReplyContext(originalMsg)
                }).catch(error => {
                    console.error(`Error sending Instagram video ${i + 1}:`, error);
                });
            } else {
                await sock.sendMessage(jid, {
                    image: mediaBuffer,
                    caption: `üñºÔ∏è *Instagram Photo ${i + 1}/${igData.mediaCount}*\n\n` +
                            `üë§ ${igData.author}\n` +
                            `üìä ${formatFileSize(media.size)}\n` +
                            `‚ù§Ô∏è ${igData.likes} likes\n` +
                            `‚è∞ ${new Date().toLocaleString('id-ID')}`,
                    ...createReplyContext(originalMsg)
                }).catch(error => {
                    console.error(`Error sending Instagram photo ${i + 1}:`, error);
                });
            }

            if (i < igData.media.length - 1) {
                await delay(2000 + Math.random() * 1000);
            }

            setTimeout(() => {
                if (fs.existsSync(media.filepath)) {
                    fs.unlinkSync(media.filepath);
                }
            }, 30000);
        }

        setTimeout(async () => {
            const totalSize = igData.media.reduce((sum, media) => sum + media.size, 0);
            
            await sendReply(sock, jid,
                `‚úÖ *INSTAGRAM DOWNLOAD COMPLETE* ‚úÖ\n\n` +
                `üìä *Summary:*\n` +
                `üë§ Author: ${igData.author}\n` +
                `üìù Type: ${igData.type}\n` +
                `üì¶ Media: ${igData.mediaCount} file\n` +
                `üíæ Total Size: ${formatFileSize(totalSize)}\n` +
                `‚ù§Ô∏è Likes: ${igData.likes}\n` +
                `üí¨ Comments: ${igData.comments}\n\n` +
                `üéØ *Download via:* Bot\n` +
                `üë§ Request by: ${pushName}\n` +
                `‚è∞ ${new Date().toLocaleString('id-ID')}\n\n` +
                `üí° Gunakan .ighelp untuk bantuan lebih lanjut`,
                originalMsg
            );
        }, 2000);

    });
}

async function handleInstagramHelp(sock, jid, msg, args, pushName, originalMsg) {
    await sendReplyWithReaction(sock, jid,
        `üì∏ *INSTAGRAM DOWNLOADER HELP* üì∏\n\n` +
        `üë§ *Supported Content Types:*\n` +
        `‚Ä¢ üì∑ Photo posts (single/multiple)\n` +
        `‚Ä¢ üé¨ Video posts & Reels\n` +
        `‚Ä¢ üìñ Instagram Stories\n` +
        `‚Ä¢ üìä IGTV videos\n` +
        `‚Ä¢ üè∑Ô∏è Tagged posts\n\n` +
        `üìå *Format URL yang didukung:*\n` +
        `1. Photo Post: https://instagram.com/p/xxxxxxxxxx\n` +
        `2. Reels: https://instagram.com/reel/xxxxxxxxxx\n` +
        `3. Story: https://instagram.com/stories/username/xxxxxxxxxx\n` +
        `4. IGTV: https://instagram.com/tv/xxxxxxxxxx\n` +
        `5. Short URL: https://ig.me/p/xxxxxxxxxx\n\n` +
        `‚öôÔ∏è *Advanced Features:*\n` +
        `‚Ä¢ Auto detect media type\n` +
        `‚Ä¢ Download multiple photos in carousel\n` +
        `‚Ä¢ HD quality preservation\n` +
        `‚Ä¢ Metadata extraction (likes, comments, caption)\n` +
        `‚Ä¢ Private post support (tergantung API)\n\n` +
        `‚ö†Ô∏è *Limitations:*\n` +
        `‚Ä¢ Maksimal 10 media per download\n` +
        `‚Ä¢ Stories hanya 24 jam terakhir\n` +
        `‚Ä¢ Private account mungkin tidak bisa\n` +
        `‚Ä¢ Rate limit 5 requests per minute\n\n` +
        `üë§ *Basic Usage:*\n` +
        `.ig <link_instagram>\n\n` +
        `üí° *Tips:*\n` +
        `‚Ä¢ Copy link dari aplikasi Instagram\n` +
        `‚Ä¢ Paste langsung tanpa edit\n` +
        `‚Ä¢ Untuk video panjang, mungkin butuh waktu lebih lama\n` +
        `‚Ä¢ Jika gagal, coba link yang berbeda\n\n` +
        `üîß *Troubleshooting:*\n` +
        `1. Pastikan link valid dan publik\n` +
        `2. Coba refresh link jika expired\n` +
        `3. Gunakan link langsung dari Instagram app\n` +
        `4. Jika tetap gagal, coba beberapa menit lagi\n\n` +
        `üëë *Need Help?*\n` +
        `Contact: wa.me/6283115105784`,
        originalMsg
    );
}

// ==================== FITUR STICKER TANPA WATERMARK ====================
async function createStickerClean(imageBuffer) {
    try {
        return await stickerAPI.createStickerFromImage(imageBuffer, {
            author: 'violation bot',
            pack: 'Sticker Pack',
            categories: ['‚ù§Ô∏è', 'üëç', 'üòä'],
            quality: 90
        });
    } catch (error) {
        console.error('Error in createStickerClean:', error);
        throw new Error(`Gagal membuat stiker: ${error.message}`);
    }
}

async function handleSticker(sock, jid, msg, args, pushName, originalMsg) {
    const hasMedia = msg.message?.imageMessage || 
                     msg.message?.videoMessage ||
                     (msg.message?.extendedTextMessage?.contextInfo?.quotedMessage?.imageMessage) ||
                     (msg.message?.extendedTextMessage?.contextInfo?.quotedMessage?.videoMessage);

    if (!hasMedia) {
        await sendReplyWithReaction(sock, jid, 
            `üõ†Ô∏è *FITUR STICKER* üõ†Ô∏è\n\n` +
            `Buat stiker dari gambar/video tanpa watermark\n\n` +
            `üìù *Cara Pakai:*\n` +
            `1. Kirim gambar/video\n` +
            `2. Reply gambar/video tersebut\n` +
            `3. Ketik *.sticker* atau *.s*\n\n` +
            `üë§ *Fitur:*\n` +
            `‚Ä¢ Clean tanpa watermark\n` +
            `‚Ä¢ Kualitas HD\n` +
            `‚Ä¢ Support gambar & video\n` +
            `‚Ä¢ Auto resize\n\n` +
            `üí° *Tips:*\n` +
            `‚Ä¢ Maksimal ukuran: 10MB\n` +
            `‚Ä¢ Format: JPG, PNG, GIF, MP4\n` +
            `‚Ä¢ Video maksimal 10 detik`,
            originalMsg
        );
        return;
    }

    await processCommandWithReaction(sock, jid, originalMsg, 'STICKER', async () => {
        let mediaBuffer;
        let mediaType;
        
        if (msg.message?.extendedTextMessage?.contextInfo?.quotedMessage) {
            const quotedMsg = {
                key: { remoteJid: jid },
                message: msg.message.extendedTextMessage.contextInfo.quotedMessage
            };
            
            if (quotedMsg.message.imageMessage) {
                mediaBuffer = await downloadMediaMessage(quotedMsg, "buffer", {});
                mediaType = 'image';
            } else if (quotedMsg.message.videoMessage) {
                mediaBuffer = await downloadMediaMessage(quotedMsg, "buffer", {});
                mediaType = 'video';
            }
        } else {
            if (msg.message.imageMessage) {
                mediaBuffer = await downloadMediaMessage(msg, "buffer", {});
                mediaType = 'image';
            } else if (msg.message.videoMessage) {
                mediaBuffer = await downloadMediaMessage(msg, "buffer", {});
                mediaType = 'video';
            }
        }

        if (!mediaBuffer || mediaBuffer.length === 0) {
            throw new Error('Gagal mengambil media. Coba dengan media yang berbeda.');
        }

        if (mediaBuffer.length > 10 * 1024 * 1024) {
            throw new Error("Media terlalu besar! Maksimal 10MB.");
        }

        let stickerBuffer;
        
        if (mediaType === 'image') {
            stickerBuffer = await createStickerClean(mediaBuffer);
        } else if (mediaType === 'video') {
            const tempVideoPath = path.join(tempDir, `temp_video_${Date.now()}.mp4`);
            const tempStickerPath = path.join(tempDir, `sticker_${Date.now()}.webp`);
            
            fs.writeFileSync(tempVideoPath, mediaBuffer);
            
            try {
                await new Promise((resolve, reject) => {
                    ffmpeg(tempVideoPath)
                        .outputOptions([
                            '-vf', 'scale=512:512:force_original_aspect_ratio=decrease:force_divisible_by=2',
                            '-c:v', 'libwebp',
                            '-loop', '0',
                            '-q:v', '80',
                            '-preset', 'default',
                            '-an',
                            '-vsync', '0',
                            '-r', '15'
                        ])
                        .on('end', resolve)
                        .on('error', reject)
                        .save(tempStickerPath);
                });
                
                stickerBuffer = fs.readFileSync(tempStickerPath);
            } finally {
                if (fs.existsSync(tempVideoPath)) fs.unlinkSync(tempVideoPath);
                if (fs.existsSync(tempStickerPath)) fs.unlinkSync(tempStickerPath);
            }
        }

        if (!stickerBuffer) {
            throw new Error('Gagal membuat stiker');
        }

        await sock.sendMessage(jid, {
            sticker: stickerBuffer,
            ...createReplyContext(originalMsg)
        }).catch(error => {
            console.error('Error sending sticker:', error);
            throw error;
        });

        await delay(2000 + Math.random() * 1000);

        await sendReply(sock, jid,
            `‚úÖ *STICKER BERHASIL DIBUAT!* ‚úÖ\n\n` +
            `üë§ Oleh: ${pushName}\n` +
            `üìä Tipe: ${mediaType === 'image' ? 'Gambar' : 'Video'}\n` +
            `üñºÔ∏è Ukuran: ${(stickerBuffer.length / 1024).toFixed(2)} KB\n` +
            `üé® Fitur: Clean tanpa watermark\n\n` +
            `üèÜ Stiker siap digunakan!`,
            originalMsg
        );
    });
}

// ==================== FITUR EXECUTOR ROBLOX FREE ====================
const robloxExecutors = {
    'free': [
        {
            name: "üì± Delta Executor",
            price: "Free",
            version: "v2.698.941",
            features: [
                "Top best Android executor",
                "High stability & performance",
                "Easy to use interface",
                "Good script compatibility",
                "Regular updates"
            ],
            download: "https://www.mediafire.com/file/8emy4ffuzv9rkbh/Delta-2.698.941.apk/file",
            status: "‚úÖ Active & Updated",
            platform: "Android",
            recommendation: "üèÜ TOP BEST"
        },
        {
            name: "üì± Fluxus Z",
            price: "Free", 
            version: "New Version",
            features: [
                "New updated version",
                "Mobile & PC support",
                "User-friendly interface",
                "Good performance",
                "Regular security updates"
            ],
            download: "https://heylink.me/Fluxus",
            status: "‚úÖ Active & Updated", 
            platform: "Android & Windows",
            recommendation: "üëç EXCELLENT"
        },
        {
            name: "üì± Arceus X NEO",
            price: "Free",
            version: "v1.9.2",
            features: [
                "Latest NEO version",
                "Enhanced performance",
                "Modern UI design",
                "Good compatibility",
                "Stable execution"
            ],
            download: "https://www.mediafire.com/file/lh42jsncojxil7f/Roblox_Arceus_X_NEO_1.9.2.apk/file",
            status: "‚úÖ Active & Updated",
            platform: "Android",
            recommendation: "‚≠ê RECOMMENDED"
        },
        {
            name: "üì± Krnl",
            price: "Free",
            version: "Latest",
            features: [
                "Most popular free executor",
                "Best script compatibility",
                "Regular updates",
                "Key system for security",
                "Large community support"
            ],
            download: "https://filenetwork.vip/android.html",
            status: "‚úÖ Active & Updated",
            platform: "Android",
            recommendation: "üíé POPULAR CHOICE"
        }
    ]
};

async function handleExecutorRoblox(sock, jid, msg, args, pushName, originalMsg) {
    await processCommandWithReaction(sock, jid, originalMsg, 'EXECUTOR_ROBLOX', async () => {
        let allExecutorsText = `ü§ñ *FREE ROBLOX EXECUTORS - ${robloxExecutors.free.length} EXECUTORS* ü§ñ\n\n`;
        allExecutorsText += `üë§ Request oleh: ${pushName}\n`;
        allExecutorsText += `‚è∞ ${new Date().toLocaleString('id-ID')}\n\n`;
        
        allExecutorsText += `‚îÅ‚îÅ‚îÅ‚îÅ üì± FREE EXECUTORS ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
        
        robloxExecutors.free.forEach((executor, index) => {
            allExecutorsText += `${executor.recommendation}\n`;
            allExecutorsText += `üë§ *${executor.name}*\n`;
            allExecutorsText += `üì± Platform: ${executor.platform}\n`;
            allExecutorsText += `üîß Version: ${executor.version}\n`;
            allExecutorsText += `üí∞ Price: ${executor.price}\n`;
            allExecutorsText += `üìä Status: ${executor.status}\n\n`;
            
            allExecutorsText += `üèÜ *Features:*\n`;
            executor.features.forEach(feature => {
                allExecutorsText += `‚Ä¢ ${feature}\n`;
            });
            
            allExecutorsText += `\nüîó *Download:*\n${executor.download}\n`;
            
            if (index < robloxExecutors.free.length - 1) {
                allExecutorsText += `\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
            }
        });

        allExecutorsText += `\n‚îÅ‚îÅ‚îÅ‚îÅ üìñ CARA PENGGUNAAN ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
        allExecutorsText += `1. ‚¨áÔ∏è **Download** executor dari link di atas\n`;
        allExecutorsText += `2. üì± **Install APK** di Android (izinkan install dari sumber tidak dikenal)\n`;
        allExecutorsText += `3. üéÆ **Buka Roblox** dan masuk ke game\n`;
        allExecutorsText += `4. ü§ñ **Buka executor** dan inject ke Roblox\n`;
        allExecutorsText += `5. üìå **Copy script** dari .sc command\n`;
        allExecutorsText += `6. ‚úÖ **Paste & Execute** script\n`;
        allExecutorsText += `7. üë§ **Tunggu** hingga muncul GUI/notifikasi\n\n`;

        allExecutorsText += `‚îÅ‚îÅ‚îÅ‚îÅ ‚ö†Ô∏è TIPS KEAMANAN ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
        allExecutorsText += `‚Ä¢ üîê **Download hanya dari link resmi**\n`;
        allExecutorsText += `‚Ä¢ üõ°Ô∏è **Gunakan alt account** untuk testing\n`;
        allExecutorsText += `‚Ä¢ ‚ö†Ô∏è **Hati-hati dengan fake executor**\n`;
        allExecutorsText += `‚Ä¢ üîß **Update secara berkala**\n`;
        allExecutorsText += `‚Ä¢ üìä **Cek komunitas** untuk info terbaru\n\n`;

        allExecutorsText += `‚îÅ‚îÅ‚îÅ‚îÅ üë§ REKOMENDASI ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
        allExecutorsText += `üèÜ *TOP CHOICE:* Delta Executor\n`;
        allExecutorsText += `üëç *BEST ALTERNATIVE:* Fluxus Z\n`;
        allExecutorsText += `‚≠ê *STABLE OPTION:* Arceus X NEO\n`;
        allExecutorsText += `üíé *MOST POPULAR:* Krnl\n\n`;

        allExecutorsText += `üìä *STATISTIK:*\n`;
        allExecutorsText += `‚Ä¢ ü§ñ Total Executor: ${robloxExecutors.free.length}\n`;
        allExecutorsText += `‚Ä¢ üì± Platform: Android & Windows\n`;
        allExecutorsText += `‚Ä¢ üí∞ Price: All Free\n`;
        allExecutorsText += `‚Ä¢ üë§ Request by: ${pushName}\n`;
        allExecutorsText += `‚Ä¢ üïí ${new Date().toLocaleString('id-ID')}\n\n`;

        allExecutorsText += `üéÆ *SELAMAT MENCOBA!* üéÆ`;

        await sendReply(sock, jid, allExecutorsText, originalMsg);
    });
}

// ==================== FITUR STICKER FROM STICKERLY URL (SIPUTZX API) ====================
async function downloadStickerFromStickerly(url) {
    try {
        if (!url.includes('sticker.ly/')) {
            throw new Error('URL harus dari sticker.ly (contoh: https://sticker.ly/s/W7ES6T)');
        }

        console.log(`üì¶ Mengambil sticker dari URL: ${url}`);

        const response = await axios.post(
            'https://api.siputzx.my.id/api/sticker/stickerly-detail',
            {
                url: url
            },
            {
                headers: {
                    'accept': '*/*',
                    'Content-Type': 'application/json'
                },
                timeout: 30000
            }
        );

        if (!response.data || !response.data.status) {
            throw new Error('API tidak merespons dengan benar');
        }

        const stickerData = response.data.data;
        
        if (!stickerData || !stickerData.stickers || stickerData.stickers.length === 0) {
            throw new Error('Tidak ada sticker ditemukan di URL tersebut');
        }

        console.log(`‚úÖ Ditemukan ${stickerData.stickers.length} sticker dari pack`);

        const downloadedStickers = [];
        
        for (let i = 0; i < Math.min(stickerData.stickers.length, 10); i++) {
            try {
                const sticker = stickerData.stickers[i];
                
                if (!sticker.url) continue;

                const stickerResponse = await axios.get(sticker.url, {
                    responseType: 'arraybuffer',
                    timeout: 20000,
                    headers: {
                        'User-Agent': 'Mozilla/5.0',
                        'Referer': 'https://sticker.ly/'
                    }
                });

                if (!stickerResponse.data || stickerResponse.data.byteLength === 0) {
                    console.log(`‚ö†Ô∏è Sticker ${i + 1} kosong, dilewati`);
                    continue;
                }

                const stickerBuffer = Buffer.from(stickerResponse.data);
                const filename = `stickerly_${Date.now()}_${i + 1}.webp`;
                const filepath = path.join(tempDir, filename);

                fs.writeFileSync(filepath, stickerBuffer);

                downloadedStickers.push({
                    filepath,
                    filename,
                    buffer: stickerBuffer,
                    size: stickerBuffer.length,
                    emoji: sticker.emoji || 'üòä',
                    index: i + 1
                });

                console.log(`‚úÖ Sticker ${i + 1} berhasil diundownload: ${formatFileSize(stickerBuffer.length)}`);

                if (i < Math.min(stickerData.stickers.length, 10) - 1) {
                    await delay(1000);
                }

            } catch (stickerError) {
                console.log(`‚ö†Ô∏è Gagal download sticker ${i + 1}:`, stickerError.message);
            }
        }

        if (downloadedStickers.length === 0) {
            throw new Error('Gagal mengunduh semua sticker dari pack');
        }

        return {
            success: true,
            packName: stickerData.name || 'Sticker Pack',
            author: stickerData.author || 'violation',
            totalStickers: stickerData.stickers.length,
            downloaded: downloadedStickers.length,
            stickers: downloadedStickers,
            url: url,
            source: 'sticker.ly via Siputzx API'
        };

    } catch (error) {
        console.error('‚ùå Error downloading sticker from stickerly:', error);
        throw new Error(`Gagal mengambil sticker: ${error.message}`);
    }
}

async function handleStickerly(sock, jid, msg, args, pushName, originalMsg) {
    if (args.length < 1) {
        await sendReplyWithReaction(sock, jid,
            `üì¶ *STICKER PACK DOWNLOADER* üì¶\n\n` +
            `Download sticker pack dari URL sticker.ly!\n\n` +
            `üìå *Format:* .stickerly [url_stickerly]\n\n` +
            `üí° *Contoh:*\n` +
            `.stickerly https://sticker.ly/s/W7ES6T\n` +
            `.stickerly https://sticker.ly/s/ABC123\n\n` +
            `üíé *Fitur:*\n` +
            `‚Ä¢ Download semua sticker dalam pack\n` +
            `‚Ä¢ Auto detect jumlah sticker\n` +
            `‚Ä¢ Kualitas original\n` +
            `‚Ä¢ Support semua jenis sticker\n\n` +
            `‚ö†Ô∏è *Batasan:*\n` +
            `‚Ä¢ Maksimal 10 sticker per download\n` +
            `‚Ä¢ URL harus valid dari sticker.ly\n` +
            `‚Ä¢ Sticker pack harus public\n\n` +
            `üîó *Dapatkan URL sticker.ly:*\n` +
            `1. Buka aplikasi sticker.ly\n` +
            `2. Pilih sticker pack\n` +
            `3. Share ‚Üí Copy link\n` +
            `4. Paste di sini!`,
            originalMsg
        );
        return;
    }

    const stickerlyUrl = args[0];
    
    if (!stickerlyUrl.includes('sticker.ly/')) {
        await sendReplyWithReaction(sock, jid,
            '‚ùå *URL TIDAK VALID!*\n\n' +
            'URL harus dari sticker.ly\n' +
            'Contoh: https://sticker.ly/s/W7ES6T\n\n' +
            'Pastikan Anda menyalin link yang benar dari aplikasi sticker.ly',
            originalMsg
        );
        return;
    }

    await processCommandWithReaction(sock, jid, originalMsg, 'STICKERLY_DOWNLOAD', async () => {
        const stickerData = await downloadStickerFromStickerly(stickerlyUrl);

        await sendReply(sock, jid,
            `‚úÖ *STICKER PACK DITEMUKAN!* ‚úÖ\n\n` +
            `üì¶ Nama Pack: ${stickerData.packName}\n` +
            `üë§ Author: ${stickerData.author}\n` +
            `üìä Total Sticker: ${stickerData.totalStickers}\n` +
            `‚¨áÔ∏è Akan Download: ${stickerData.downloaded} sticker\n\n` +
            `üîÑ Mengunduh sticker...`,
            originalMsg
        );

        let successCount = 0;
        let failCount = 0;

        for (let i = 0; i < stickerData.stickers.length; i++) {
            const sticker = stickerData.stickers[i];
            
            try {
                await sock.sendMessage(jid, {
                    sticker: fs.readFileSync(sticker.filepath),
                    ...createReplyContext(originalMsg)
                });

                successCount++;
                console.log(`‚úÖ Sticker ${sticker.index} berhasil dikirim`);

                if (i < stickerData.stickers.length - 1) {
                    await delay(1500 + Math.random() * 1000);
                }

            } catch (sendError) {
                failCount++;
                console.error(`‚ùå Gagal kirim sticker ${sticker.index}:`, sendError.message);
            }

            setTimeout(() => {
                if (fs.existsSync(sticker.filepath)) {
                    fs.unlinkSync(sticker.filepath);
                }
            }, 30000);
        }

        await sendReply(sock, jid,
            `üìä *DOWNLOAD STICKER COMPLETE!* üìä\n\n` +
            `üì¶ Pack: ${stickerData.packName}\n` +
            `‚úÖ Berhasil: ${successCount} sticker\n` +
            `‚ùå Gagal: ${failCount} sticker\n` +
            `üìä Total: ${stickerData.totalStickers} sticker\n\n` +
            `üë§ Request by: ${pushName}\n` +
            `üîó URL: ${stickerlyUrl}\n` +
            `‚è∞ ${new Date().toLocaleString('id-ID')}\n\n` +
            `üí° *Tips:*\n` +
            `‚Ä¢ Simpan sticker favorit Anda!\n` +
            `‚Ä¢ Bagikan ke teman-teman!\n` +
            `‚Ä¢ Cari sticker pack lain di sticker.ly`,
            originalMsg
        );
    });
}

// ==================== FITUR STICKER PACK INFO ====================
async function getStickerPackInfo(url) {
    try {
        const response = await axios.post(
            'https://api.siputzx.my.id/api/sticker/stickerly-detail',
            {
                url: url
            },
            {
                headers: {
                    'accept': '*/*',
                    'Content-Type': 'application/json'
                },
                timeout: 15000
            }
        );

        if (!response.data || !response.data.status) {
            throw new Error('API tidak merespons');
        }

        const data = response.data.data;
        
        return {
            success: true,
            name: data.name || 'Unknown Pack',
            author: data.author || 'violation bot',
            totalStickers: data.stickers?.length || 0,
            previews: data.stickers?.slice(0, 5).map(s => s.emoji || 'üñºÔ∏è') || [],
            url: url,
            timestamp: new Date().toISOString()
        };

    } catch (error) {
        console.error('Error getting sticker pack info:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleStickerInfo(sock, jid, msg, args, pushName, originalMsg) {
    if (args.length < 1) {
        await sendReplyWithReaction(sock, jid,
            `üìã *STICKER PACK INFO* üìã\n\n` +
            `Lihat informasi sticker pack sebelum mendownload!\n\n` +
            `üìå *Format:* .stickerinfo [url_stickerly]\n\n` +
            `üí° *Contoh:*\n` +
            `.stickerinfo https://sticker.ly/s/W7ES6T\n\n` +
            `üìä *Informasi yang ditampilkan:*\n` +
            `‚Ä¢ Nama sticker pack\n` +
            `‚Ä¢ Pembuat (author)\n` +
            `‚Ä¢ Jumlah total sticker\n` +
            `‚Ä¢ Preview emoji\n` +
            `‚Ä¢ Status pack\n\n` +
            `‚ö†Ô∏è *Note:*\n` +
            `Hanya untuk URL sticker.ly yang valid`,
            originalMsg
        );
        return;
    }

    const stickerlyUrl = args[0];
    
    if (!stickerlyUrl.includes('sticker.ly/')) {
        await sendReplyWithReaction(sock, jid,
            '‚ùå URL harus dari sticker.ly!',
            originalMsg
        );
        return;
    }

    await processCommandWithReaction(sock, jid, originalMsg, 'STICKER_INFO', async () => {
        const packInfo = await getStickerPackInfo(stickerlyUrl);

        if (!packInfo.success) {
            throw new Error(`Gagal mendapatkan info: ${packInfo.error}`);
        }

        let infoText = `üìã *STICKER PACK INFORMATION* üìã\n\n`;
        infoText += `üì¶ *Nama Pack:* ${packInfo.name}\n`;
        infoText += `üë§ *Author:* ${packInfo.author}\n`;
        infoText += `üìä *Total Sticker:* ${packInfo.totalStickers}\n`;
        infoText += `üîó *URL:* ${stickerlyUrl}\n\n`;
        
        if (packInfo.previews.length > 0) {
            infoText += `üëÄ *Preview:* ${packInfo.previews.join(' ')}\n\n`;
        }

        infoText += `üí° *Status:* ‚úÖ AVAILABLE\n`;
        infoText += `üìÖ *Last Check:* ${new Date(packInfo.timestamp).toLocaleString('id-ID')}\n\n`;
        
        infoText += `‚¨áÔ∏è *Download dengan:*\n`;
        infoText += `‚Ä¢ .stickerly ${stickerlyUrl}\n\n`;
        infoText += `‚ö†Ô∏è *Note:*\n`;
        infoText += `‚Ä¢ Maksimal 10 sticker akan didownload\n`;
        infoText += `‚Ä¢ Sticker pack harus public\n`;
        infoText += `‚Ä¢ Proses download mungkin memakan waktu`;

        await sendReply(sock, jid, infoText, originalMsg);
    });
}

// ==================== FITUR STICKER SEARCH (SIPUTZX) ====================
async function searchStickerPacks(query, limit = 5) {
    try {
        const response = await axios.get(
            `https://api.siputzx.my.id/api/sticker/search`,
            {
                params: {
                    query: query,
                    limit: limit
                },
                timeout: 15000
            }
        );

        if (!response.data || !response.data.status) {
            throw new Error('API tidak merespons');
        }

        const results = response.data.data || [];
        
        return {
            success: true,
            results: results,
            count: results.length,
            query: query
        };

    } catch (error) {
        console.error('Error searching sticker packs:', error);
        return {
            success: false,
            error: error.message
        };
    }
}

async function handleSearchSticker(sock, jid, msg, args, pushName, originalMsg) {
    if (args.length < 1) {
        await sendReplyWithReaction(sock, jid,
            `üîç *SEARCH STICKER PACKS* üîç\n\n` +
            `Cari sticker pack berdasarkan kata kunci!\n\n` +
            `üìå *Format:* .searchsticker [kata_kunci]\n\n` +
            `üí° *Contoh:*\n` +
            `.searchsticker anime\n` +
            `.searchsticker cute\n` +
            `.searchsticker funny cat\n\n` +
            `üìä *Hasil pencarian akan menampilkan:*\n` +
            `‚Ä¢ Nama sticker pack\n` +
            `‚Ä¢ Author\n` +
            `‚Ä¢ Jumlah sticker\n` +
            `‚Ä¢ URL untuk download\n\n` +
            `üîó *Setelah menemukan pack yang diinginkan:*\n` +
            `Gunakan .stickerly [url] untuk download\n` +
            `Atau .stickerinfo [url] untuk lihat detail`,
            originalMsg
        );
        return;
    }

    const searchQuery = args.join(' ');

    await processCommandWithReaction(sock, jid, originalMsg, 'SEARCH_STICKER', async () => {
        const searchResult = await searchStickerPacks(searchQuery, 5);

        if (!searchResult.success) {
            throw new Error(`Gagal mencari: ${searchResult.error}`);
        }

        if (searchResult.count === 0) {
            await sendReply(sock, jid,
                `üîç *TIDAK ADA HASIL* üîç\n\n` +
                `Tidak ditemukan sticker pack untuk:\n` +
                `"${searchQuery}"\n\n` +
                `üí° *Tips:*\n` +
                `‚Ä¢ Gunakan kata kunci yang lebih spesifik\n` +
                `‚Ä¢ Coba kata kunci dalam Bahasa Inggris\n` +
                `‚Ä¢ Contoh: anime, cute, funny, love, animal`,
                originalMsg
            );
            return;
        }

        let searchText = `üîç *HASIL PENCARIAN STICKER* üîç\n\n`;
        searchText += `üìù *Kata kunci:* ${searchQuery}\n`;
        searchText += `üìä *Ditemukan:* ${searchResult.count} pack\n\n`;
        
        searchResult.results.forEach((pack, index) => {
            searchText += `${index + 1}. *${pack.name || 'Unknown'}*\n`;
            searchText += `   üë§ ${pack.author || 'Unknown'}\n`;
            searchText += `   üìä ${pack.totalStickers || 0} sticker\n`;
            
            if (pack.url) {
                const shortUrl = pack.url.replace('https://sticker.ly/s/', '');
                searchText += `   üîó ${shortUrl}\n`;
            }
            
            searchText += `\n`;
        });

        searchText += `üí° *Cara download:*\n`;
        searchText += `Gunakan .stickerly [url] untuk mendownload pack\n`;
        searchText += `Contoh: .stickerly https://sticker.ly/s/W7ES6T\n\n`;
        searchText += `üìÖ *Hasil pencarian:* ${new Date().toLocaleString('id-ID')}`;

        await sendReply(sock, jid, searchText, originalMsg);
    });
}

// ==================== FITUR MEDIAFIRE DOWNLOADER ====================
async function downloadMediaFire(url) {
    try {
        let mediafireUrl = url.trim();
        if (!mediafireUrl.startsWith('http')) {
            mediafireUrl = 'https://' + mediafireUrl;
        }

        console.log(`‚¨áÔ∏è Processing MediaFire URL: ${mediafireUrl}`);

        const urlPatterns = [
            /mediafire\.com\/\?(\w+)/,
            /mediafire\.com\/file\/(\w+)/,
            /mediafire\.com\/download\/(\w+)/,
            /mediafire\.com\/view\/(\w+)/
        ];

        let fileKey = null;
        for (const pattern of urlPatterns) {
            const match = mediafireUrl.match(pattern);
            if (match) {
                fileKey = match[1];
                break;
            }
        }

        if (!fileKey) {
            try {
                const urlObj = new URL(mediafireUrl);
                fileKey = urlObj.searchParams.get('key') || urlObj.pathname.split('/').pop();
            } catch (e) {
                throw new Error('Format URL MediaFire tidak valid');
            }
        }

        if (!fileKey) {
            throw new Error('Tidak dapat menemukan file key dari URL');
        }

        console.log(`üîë MediaFire File Key: ${fileKey}`);

        const apiEndpoints = [
            `https://www.mediafire.com/api/1.5/file/get_info.php?key=${fileKey}&response_format=json`,
            `https://www.mediafire.com/api/1.4/file/get_info.php?quick_key=${fileKey}&response_format=json`
        ];

        let fileInfo = null;
        for (const apiUrl of apiEndpoints) {
            try {
                const response = await axios.get(apiUrl, {
                    timeout: 15000,
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                        'Accept': 'application/json'
                    }
                });

                if (response.data && response.data.response && response.data.response.file_info) {
                    fileInfo = response.data.response.file_info;
                    break;
                }
            } catch (error) {
                console.log(`API ${apiUrl} failed:`, error.message);
                continue;
            }
        }

        if (!fileInfo) {
            try {
                const response = await axios.get(`https://www.mediafire.com/file/${fileKey}`, {
                    timeout: 15000,
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
                    }
                });

                const $ = cheerio.load(response.data);

                const filename = $('div.filename').text() || `file_${fileKey}`;
                const filesize = $('div.file-size').text() || 'Unknown';
                const downloadLink = $('a#downloadButton').attr('href');

                if (downloadLink) {
                    fileInfo = {
                        filename: filename.trim(),
                        size: filesize.trim(),
                        download_url: downloadLink
                    };
                } else {
                    throw new Error('Tidak dapat menemukan link download');
                }
            } catch (scrapeError) {
                throw new Error('Gagal mendapatkan info file dari MediaFire');
            }
        }

        const downloadUrl = fileInfo.download_url || `https://download${Math.floor(Math.random() * 10) + 1}.mediafire.com/${fileKey}/${fileInfo.filename}`;
        
        console.log(`‚¨áÔ∏è Downloading from: ${downloadUrl}`);

        const response = await axios({
            method: 'GET',
            url: downloadUrl,
            responseType: 'stream',
            timeout: 300000,
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
                'Referer': 'https://www.mediafire.com/',
                'Accept': '*/*'
            }
        });

        const originalFilename = fileInfo.filename || `mediafire_${fileKey}`;
        const safeFilename = originalFilename.replace(/[^a-zA-Z0-9._-]/g, '_');
        const filepath = path.join(tempDir, safeFilename);

        const writer = fs.createWriteStream(filepath);
        response.data.pipe(writer);

        return new Promise((resolve, reject) => {
            writer.on('finish', () => {
                const stats = fs.statSync(filepath);
                resolve({
                    filepath,
                    filename: safeFilename,
                    size: stats.size,
                    originalFilename: originalFilename,
                    fileSize: fileInfo.size || formatFileSize(stats.size),
                    mimetype: response.headers['content-type'] || 'application/octet-stream',
                    fileKey: fileKey
                });
            });
            writer.on('error', reject);
        });

    } catch (error) {
        throw new Error(`MediaFire download error: ${error.message}`);
    }
}

async function handleMediaFire(sock, jid, msg, args, pushName, originalMsg) {
    if (args.length < 1) {
        await sendReplyWithReaction(sock, jid,
            `‚¨áÔ∏è *MEDIAFIRE DOWNLOADER* ‚¨áÔ∏è\n\n` +
            `Download file dari MediaFire langsung ke WhatsApp!\n\n` +
            `üì§ *Format:* .mediafire <link_mediafire>\n\n` +
            `üìù *Contoh:*\n` +
            `.mediafire https://www.mediafire.com/file/abc123/file.zip\n` +
            `.mediafire mediafire.com/file/xyz789/document.pdf\n\n` +
            `üí° *Fitur:*\n` +
            `‚Ä¢ Support semua jenis file\n` +
            `‚Ä¢ Auto detect filename\n` +
            `‚Ä¢ Progress indicator\n` +
            `‚Ä¢ File size limit: 100MB\n\n` +
            `‚ö†Ô∏è *Note:* Hanya untuk file public yang bisa didownload`,
            originalMsg
        );
        return;
    }

    const mediafireUrl = args[0];
    
    if (!mediafireUrl.includes('mediafire.com')) {
        await sendReplyWithReaction(sock, jid, '‚ùå Bukan link MediaFire yang valid!', originalMsg);
        return;
    }

    await processCommandWithReaction(sock, jid, originalMsg, 'MEDIAFIRE', async () => {
        let fileInfo;
        
        try {
            fileInfo = await downloadMediaFire(mediafireUrl);
        } catch (firstError) {
            console.log('Method 1 failed:', firstError.message);
            throw new Error(`Download gagal: ${firstError.message}`);
        }

        const maxSize = 100 * 1024 * 1024;
        if (fileInfo.size > maxSize) {
            await sendReply(sock, jid,
                `‚ùå *FILE TERLALU BESAR* ‚ùå\n\n` +
                `Nama: ${fileInfo.originalFilename}\n` +
                `Ukuran: ${formatFileSize(fileInfo.size)}\n` +
                `Maksimal: 100MB\n\n` +
                `üì§ File terlalu besar untuk dikirim via WhatsApp.`,
                originalMsg
            );
            
            if (fs.existsSync(fileInfo.filepath)) {
                fs.unlinkSync(fileInfo.filepath);
            }
            return;
        }

        const fileBuffer = fs.readFileSync(fileInfo.filepath);

        await sendReply(sock, jid,
            `‚úÖ *DOWNLOAD BERHASIL!* ‚úÖ\n\n` +
            `üìÑ Nama: ${fileInfo.originalFilename}\n` +
            `üìä Ukuran: ${formatFileSize(fileInfo.size)}\n` +
            `üë§ Tipe: ${fileInfo.mimetype}\n` +
            `üë§ User: ${pushName}\n\n` +
            `‚¨ÜÔ∏è Mengirim file...`,
            originalMsg
        );

        const fileExtension = path.extname(fileInfo.filename).toLowerCase();

        if (fileInfo.mimetype.startsWith('image/')) {
            await sock.sendMessage(jid, {
                image: fileBuffer,
                caption: `üñºÔ∏è ${fileInfo.originalFilename}\n‚¨áÔ∏è Downloaded via MediaFire`,
                ...createReplyContext(originalMsg)
            }).catch(error => {
                console.error('Error sending image:', error);
                throw error;
            });
        } 
        else if (fileInfo.mimetype.startsWith('video/') || ['.mp4', '.avi', '.mkv', '.mov'].includes(fileExtension)) {
            await sock.sendMessage(jid, {
                video: fileBuffer,
                caption: `üé¨ ${fileInfo.originalFilename}\n‚¨áÔ∏è Downloaded via MediaFire`,
                ...createReplyContext(originalMsg)
            }).catch(error => {
                console.error('Error sending video:', error);
                throw error;
            });
        }
        else if (fileInfo.mimetype.startsWith('audio/') || ['.mp3', '.wav', '.aac', '.flac'].includes(fileExtension)) {
            await sock.sendMessage(jid, {
                audio: fileBuffer,
                mimetype: 'audio/mpeg',
                fileName: fileInfo.originalFilename,
                ...createReplyContext(originalMsg)
            }).catch(error => {
                console.error('Error sending audio:', error);
                throw error;
            });
        }
        else if (fileInfo.mimetype.includes('pdf') || fileExtension === '.pdf') {
            await sock.sendMessage(jid, {
                document: fileBuffer,
                fileName: fileInfo.originalFilename,
                mimetype: 'application/pdf',
                ...createReplyContext(originalMsg)
            }).catch(error => {
                console.error('Error sending PDF:', error);
                throw error;
            });
        }
        else if (fileInfo.mimetype.includes('zip') || ['.zip', '.rar', '.7z'].includes(fileExtension)) {
            await sock.sendMessage(jid, {
                document: fileBuffer,
                fileName: fileInfo.originalFilename,
                mimetype: 'application/zip',
                ...createReplyContext(originalMsg)
            }).catch(error => {
                console.error('Error sending ZIP:', error);
                throw error;
            });
        }
        else {
            await sock.sendMessage(jid, {
                document: fileBuffer,
                fileName: fileInfo.originalFilename,
                mimetype: fileInfo.mimetype,
                caption: `üìé ${fileInfo.originalFilename}\n‚¨áÔ∏è Downloaded via MediaFire`,
                ...createReplyContext(originalMsg)
            }).catch(error => {
                console.error('Error sending document:', error);
                throw error;
            });
        }

        setTimeout(() => {
            if (fs.existsSync(fileInfo.filepath)) {
                fs.unlinkSync(fileInfo.filepath);
                console.log(`üóëÔ∏è MediaFire file cleaned: ${fileInfo.filename}`);
            }
        }, 30000);
    });
}

// ==================== FITUR IP (TWITTER SCREENSHOT) - ALTERNATIVE API ====================
async function generateTwitterScreenshot(data) {
    try {
        const {
            profile = 'https://avatars.githubusercontent.com/u/159487561?v=4',
            name = 'siputzx',
            username = 'siputzx',
            tweet = 'Hello World',
            image = null,
            theme = 'dark',
            retweets = 1000,
            quotes = 200,
            likes = 5000,
            client = 'Twitter for iPhone'
        } = data;

        const apiUrls = [
            `https://some-random-api.com/canvas/tweet?avatar=${encodeURIComponent(profile)}&displayname=${encodeURIComponent(name)}&username=${encodeURIComponent(username)}&comment=${encodeURIComponent(tweet)}&replies=${quotes}&retweets=${retweets}&likes=${likes}`,
            `https://api.popcat.xyz/tweet?text=${encodeURIComponent(tweet)}&name=${encodeURIComponent(name)}&username=${encodeURIComponent(username)}&avatar=${encodeURIComponent(profile)}&theme=${theme}`,
            `https://api.memegen.link/images/custom/${encodeURIComponent(tweet.substring(0, 100))}.png?background=https://i.imgur.com/oQs8qrc.png`
        ];

        let screenshotBuffer = null;
        let lastError = null;

        for (let i = 0; i < apiUrls.length; i++) {
            try {
                console.log(`üåê Mencoba API ${i + 1}: ${apiUrls[i].split('?')[0]}`);
                
                const response = await axios.get(apiUrls[i], {
                    responseType: 'arraybuffer',
                    timeout: 30000,
                    headers: {
                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                        'Accept': 'image/*'
                    }
                });

                if (response.data && response.data.byteLength > 0) {
                    screenshotBuffer = Buffer.from(response.data);
                    console.log(`‚úÖ API ${i + 1} berhasil, ukuran: ${screenshotBuffer.length} bytes`);
                    break;
                }
            } catch (apiError) {
                lastError = apiError;
                console.log(`‚ö†Ô∏è API ${i + 1} gagal:`, apiError.message);
                continue;
            }
        }

        if (!screenshotBuffer) {
            console.log('üîß Membuat gambar manual...');
            screenshotBuffer = await createManualTweetImage(data);
        }

        return screenshotBuffer;
    } catch (error) {
        console.error('Error generating Twitter screenshot:', error);
        throw new Error(`Gagal membuat screenshot tweet: ${error.message}`);
    }
}

async function createManualTweetImage(data) {
    const {
        profile = 'https://avatars.githubusercontent.com/u/159487561?v=4',
        name = 'siputzx',
        username = 'siputzx',
        tweet = 'Hello World',
        theme = 'dark',
        retweets = 1000,
        quotes = 200,
        likes = 5000
    } = data;

    try {
        let profileImage;
        try {
            const response = await axios.get(profile, { 
                responseType: 'arraybuffer',
                timeout: 10000 
            });
            profileImage = await sharp(response.data)
                .resize(48, 48)
                .toBuffer();
        } catch {
            profileImage = await sharp({
                create: {
                    width: 48,
                    height: 48,
                    channels: 4,
                    background: { r: 29, g: 161, b: 242, alpha: 1 }
                }
            })
            .composite([{
                input: Buffer.from(
                    `<svg width="48" height="48">
                        <text x="24" y="28" font-family="Arial" font-size="20" 
                              fill="white" text-anchor="middle">${name.charAt(0)}</text>
                    </svg>`
                )
            }])
            .png()
            .toBuffer();
        }

        const formatNumber = (num) => {
            if (num >= 1000000) return (num / 1000000).toFixed(1) + 'M';
            if (num >= 1000) return (num / 1000).toFixed(1) + 'K';
            return num.toString();
        };

        const bgColor = theme === 'light' ? '#FFFFFF' : '#15202B';
        const textColor = theme === 'light' ? '#0F1419' : '#E7E9EA';
        const secondaryColor = theme === 'light' ? '#536471' : '#8B98A5';
        
        const svgContent = `
            <svg width="600" height="400" xmlns="http://www.w3.org/2000/svg">
                <!-- Background -->
                <rect width="100%" height="100%" fill="${bgColor}"/>
                
                <!-- Header -->
                <rect x="0" y="0" width="600" height="53" fill="${theme === 'light' ? '#F7F9F9' : '#192734'}"/>
                
                <!-- Twitter Logo -->
                <text x="20" y="35" font-family="Arial" font-size="20" font-weight="bold" fill="#1D9BF0">üê¶</text>
                <text x="50" y="35" font-family="Arial" font-size="16" fill="${textColor}">Tweet</text>
                
                <!-- Profile -->
                <image href="data:image/png;base64,${profileImage.toString('base64')}" x="20" y="70" width="48" height="48"/>
                <text x="80" y="90" font-family="Arial" font-size="16" font-weight="bold" fill="${textColor}">${name}</text>
                <text x="80" y="110" font-family="Arial" font-size="14" fill="${secondaryColor}">${username} ¬∑ Just now</text>
                
                <!-- Tweet Content -->
                <text x="20" y="160" font-family="Arial" font-size="16" fill="${textColor}" width="560">${tweet.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</text>
                
                <!-- Tweet Stats -->
                <text x="20" y="300" font-family="Arial" font-size="14" fill="${secondaryColor}">
                    <tspan font-weight="bold" fill="${textColor}">${formatNumber(retweets)}</tspan> Retweets  
                    <tspan font-weight="bold" fill="${textColor}">${formatNumber(quotes)}</tspan> Quotes  
                    <tspan font-weight="bold" fill="${textColor}">${formatNumber(likes)}</tspan> Likes
                </text>
                
                <!-- Footer -->
                <line x1="20" y1="350" x2="580" y2="350" stroke="${secondaryColor}" stroke-width="1"/>
                <text x="20" y="380" font-family="Arial" font-size="12" fill="${secondaryColor}">Twitter for iPhone</text>
            </svg>
        `;

        return await sharp(Buffer.from(svgContent))
            .png()
            .toBuffer();

    } catch (error) {
        console.error('Error creating manual tweet image:', error);
        
        const simpleText = `
            üê¶ TWEET PREVIEW üê¶
            
            üë§ ${name} (${username})
            ‚è∞ Just now
            
            üí¨ ${tweet}
            
            üìä ${retweets} Retweets ‚Ä¢ ${quotes} Quotes ‚Ä¢ ${likes} Likes
            üì± Twitter for iPhone
            üé® Theme: ${theme}
        `;
        
        return Buffer.from(simpleText);
    }
}

async function handleTwitterScreenshot(sock, jid, msg, args, pushName, originalMsg) {
    if (args.length < 1 || args[0] === 'help') {
        await sendReplyWithReaction(sock, jid,
            `üê¶ *TWITTER SCREENSHOT MAKER* üê¶\n\n` +
            `Buat screenshot tweet kustom dengan mudah!\n\n` +
            `üìå *Format Sederhana:*\n` +
            `.ip [tweet_text]\n\n` +
            `üìå *Format Lengkap:*\n` +
            `.ip teks="tweet" nama="nama" user="@username"\n\n` +
            `üí° *Contoh:*\n` +
            `.ip Halo dunia! Ini adalah tweet pertama saya üê¶\n\n` +
            `üí° *Contoh Lengkap:*\n` +
            `.ip teks="Halo Twitter!" nama="Adit" user="@aditaja" theme=light\n\n` +
            `üé® *Parameter Opsional:*\n` +
            `‚Ä¢ nama: Nama tampilan (default: ${pushName})\n` +
            `‚Ä¢ user: @username (default: @${(pushName || 'user').toLowerCase().replace(/\s+/g, '')})\n` +
            `‚Ä¢ theme: light/dark (default: dark)\n` +
            `‚Ä¢ rt: jumlah retweet (default: 1000)\n` +
            `‚Ä¢ like: jumlah like (default: 5000)\n\n` +
            `üèÜ *Fitur:*\n` +
            `‚Ä¢ Auto generate screenshot\n` +
            `‚Ä¢ Support light/dark theme\n` +
            `‚Ä¢ Profile picture custom\n` +
            `‚Ä¢ Real tweet design`,
            originalMsg
        );
        return;
    }

    await processCommandWithReaction(sock, jid, originalMsg, 'TWITTER_SCREENSHOT', async () => {
        const fullText = args.join(' ');
        let tweetText = fullText;
        let name = pushName || 'User';
        let username = `@${(pushName || 'user').toLowerCase().replace(/\s+/g, '')}`;
        let theme = 'dark';
        let retweets = 1000;
        let likes = 5000;
        let quotes = 200;

        if (fullText.includes('=')) {
            const params = {};
            const regex = /(\w+)=([^=]+)(?=\s+\w+=|$)/g;
            let match;
            
            while ((match = regex.exec(fullText)) !== null) {
                const key = match[1].toLowerCase();
                let value = match[2].trim();
                
                if (value.startsWith('"') && value.endsWith('"')) {
                    value = value.slice(1, -1);
                }
                
                params[key] = value;
            }

            tweetText = params.teks || params.text || params.tweet || fullText.split('=')[1] || fullText;
            name = params.nama || params.name || name;
            username = params.user || params.username || username;
            theme = params.theme === 'light' ? 'light' : 'dark';
            retweets = parseInt(params.rt) || parseInt(params.retweets) || 1000;
            likes = parseInt(params.like) || parseInt(params.likes) || 5000;
            quotes = parseInt(params.quote) || parseInt(params.quotes) || 200;
        }

        if (!tweetText || tweetText.trim().length === 0) {
            throw new Error('Teks tweet tidak boleh kosong!');
        }

        if (tweetText.length > 280) {
            await sendReply(sock, jid, 
                `‚ö†Ô∏è *PERINGATAN:* Tweet terlalu panjang (${tweetText.length}/280 karakter)\n` +
                `Akan dipotong menjadi 280 karakter.`,
                originalMsg
            );
            tweetText = tweetText.substring(0, 280);
        }

        console.log(`üé® Membuat tweet screenshot untuk ${name}: "${tweetText.substring(0, 50)}..."`);

        await sendReply(sock, jid,
            `‚è≥ *MEMBUAT TWEET SCREENSHOT* ‚è≥\n\n` +
            `üë§ ${name}\n` +
            `üê¶ ${username}\n` +
            `üí¨ ${tweetText.substring(0, 100)}${tweetText.length > 100 ? '...' : ''}\n` +
            `üé® Theme: ${theme}\n` +
            `üìä Stats: ${retweets} RT ‚Ä¢ ${likes} Likes\n\n` +
            `üîÑ Mengenerate...`,
            originalMsg
        );

        const screenshotData = {
            profile: 'https://avatars.githubusercontent.com/u/159487561?v=4',
            name: name,
            username: username,
            tweet: tweetText,
            theme: theme,
            retweets: retweets,
            quotes: quotes,
            likes: likes,
            client: 'Twitter for iPhone'
        };

        const screenshotBuffer = await generateTwitterScreenshot(screenshotData);
        
        if (!screenshotBuffer || screenshotBuffer.length === 0) {
            throw new Error('Gagal membuat screenshot tweet');
        }

        await sock.sendMessage(jid, {
            image: screenshotBuffer,
            caption: `üê¶ *TWEET SCREENSHOT* üê¶\n\n` +
                    `üë§ ${name} ${username}\n` +
                    `üí¨ ${tweetText}\n` +
                    `üìä ${retweets} Retweets ‚Ä¢ ${quotes} Quotes ‚Ä¢ ${likes} Likes\n` +
                    `üé® Theme: ${theme}\n` +
                    `üì± Twitter for iPhone\n\n` +
                    `üë§ Dibuat oleh: ${pushName}\n` +
                    `‚è∞ ${new Date().toLocaleString('id-ID')}`,
            ...createReplyContext(originalMsg)
        });

        await delay(1000);
        
        await sendReply(sock, jid,
            `‚úÖ *TWEET SCREENSHOT BERHASIL DIBUAT!* ‚úÖ\n\n` +
            `üìä *Detail:*\n` +
            `üë§ Author: ${name}\n` +
            `üê¶ Username: ${username}\n` +
            `üí¨ Tweet: ${tweetText.length > 50 ? tweetText.substring(0, 50) + '...' : tweetText}\n` +
            `üé® Theme: ${theme}\n` +
            `üìà Engagement: ${retweets} RT, ${likes} Likes\n\n` +
            `üí° *Tips:*\n` +
            `‚Ä¢ Gunakan .ip help untuk bantuan lengkap\n` +
            `‚Ä¢ Bagikan ke status WhatsApp!\n` +
            `‚Ä¢ Buat tweet lucu atau inspiratif`,
            originalMsg
        );
    });
}

async function handleIPQuick(sock, jid, msg, args, pushName, originalMsg) {
    if (args.length < 1) {
        await sendReplyWithReaction(sock, jid,
            `üê¶ *TWITTER SCREENSHOT QUICK* üê¶\n\n` +
            `Buat tweet dengan cepat!\n\n` +
            `üìå *Cara 1:* .ip [tweet]\n` +
            `Contoh: .ip Halo Twitter! üê¶\n\n` +
            `üìå *Cara 2:* Reply pesan + .ip\n` +
            `Bot akan membuat tweet dari pesan yang di-reply\n\n` +
            `üé® *Otomatis akan:*\n` +
            `‚Ä¢ Gunakan nama WhatsApp Anda\n` +
            `‚Ä¢ Generate @username otomatis\n` +
            `‚Ä¢ Dark theme yang keren\n` +
            `‚Ä¢ Stats yang realistis\n\n` +
            `üèÜ Coba sekarang!`,
            originalMsg
        );
        return;
    }

    await handleTwitterScreenshot(sock, jid, msg, args, pushName, originalMsg);
}

async function handleRVO(sock, jid, msg, originalMsg) {
    const quoted = msg.message?.extendedTextMessage?.contextInfo?.quotedMessage
    if (!quoted) {
        await sendReplyWithReaction(
            sock,
            jid,
            '‚ùå Reply pesan *View Once* yang mau dibuka!',
            originalMsg
        )
        return;
    }

    const lastMedia = [...viewOnceMedia.values()].pop()
    if (!lastMedia) {
        await sendReplyWithReaction(
            sock,
            jid,
            '‚ùå Tidak ada media View Once tersimpan!',
            originalMsg
        )
        return;
    }

    lastMedia.viewCount++

    if (lastMedia.type === 'imageMessage') {
        await sock.sendMessage(jid, {
            image: fs.readFileSync(lastMedia.filepath),
            caption:
                `üïí *REVEAL VIEW ONCE*\n\n` +
                `üñºÔ∏è Tipe: Foto\n` +
                `üëÅÔ∏è Dibuka: ${lastMedia.viewCount}x\n` +
                `üìù Caption: ${lastMedia.caption || '-'}`
        }, { quoted: originalMsg })
    }

    if (lastMedia.type === 'videoMessage') {
        await sock.sendMessage(jid, {
            video: fs.readFileSync(lastMedia.filepath),
            caption:
                `üïí *REVEAL VIEW ONCE*\n\n` +
                `üé• Tipe: Video\n` +
                `üëÅÔ∏è Dibuka: ${lastMedia.viewCount}x\n` +
                `üìù Caption: ${lastMedia.caption || '-'}`
        }, { quoted: originalMsg })
    }
}

// ==================== FITUR HITAMKAN GAMBAR ====================
async function hitamkanGambar(imageBuffer) {
    try {
        const processedBuffer = await sharp(imageBuffer)
            .greyscale()
            .modulate({ brightness: 0.7 })
            .normalise()
            .jpeg({ quality: 90 })
            .toBuffer();
            
        return processedBuffer;
    } catch (error) {
        throw new Error(`Gagal memproses gambar: ${error.message}`);
    }
}

async function handleHitamkan(sock, jid, msg, args, pushName, originalMsg) {
    const hasImage = msg.message?.imageMessage || 
                    (msg.message?.extendedTextMessage?.contextInfo?.quotedMessage?.imageMessage);

    if (!hasImage) {
        await sendReplyWithReaction(sock, jid, 
            'üõ†Ô∏è *FITUR HITAMKAN GAMBAR*\n\n' +
            'Ubah gambar menjadi efek hitam-putih yang dramatis!\n\n' +
            'üìã *Cara penggunaan:*\n' +
            '‚Ä¢ Reply sebuah foto dengan caption *.hitamkan*\n' +
            '‚Ä¢ Atau kirim foto dengan caption *.hitamkan*\n\n' +
            'üí° *Contoh:*\n' +
            'Reply foto lalu ketik .hitamkan\n\n' +
            'üèÜ *Fitur:*\n' +
            '- Efek hitam-putih profesional\n' +
            '- Kontras yang ditingkatkan\n' +
            '- Kualitas gambar terjaga',
            originalMsg
        );
        return;
    }

    await processCommandWithReaction(sock, jid, originalMsg, 'HITAMKAN', async () => {
        let imageBuffer;
        
        if (msg.message?.extendedTextMessage?.contextInfo?.quotedMessage?.imageMessage) {
            const quotedMsg = {
                key: { remoteJid: jid },
                message: msg.message.extendedTextMessage.contextInfo.quotedMessage
            };
            imageBuffer = await downloadMediaMessage(quotedMsg, "buffer", {});
        } else {
            imageBuffer = await downloadMediaMessage(msg, "buffer", {});
        }

        if (!imageBuffer || imageBuffer.length === 0) {
            throw new Error('Gagal mengambil gambar. Coba dengan gambar yang berbeda.');
        }

        if (imageBuffer.length > 10 * 1024 * 1024) {
            throw new Error("Gambar terlalu besar! Maksimal 10MB.");
        }

        const originalMetadata = await sharp(imageBuffer).metadata();
        const originalSize = imageBuffer.length;
        
        const processedBuffer = await hitamkanGambar(imageBuffer);
        const processedMetadata = await sharp(processedBuffer).metadata();
        const processedSize = processedBuffer.length;

        await sock.sendMessage(jid, {
            image: processedBuffer,
            caption: `‚óºÔ∏è *HITAM-PUTIH BERHASIL* ‚óºÔ∏è\n\n` +
                    `üë§ Diproses oleh: ${pushName}\n` +
                    `‚è∞ Waktu: ${new Date().toLocaleString('id-ID')}\n` +
                    `üñºÔ∏è Resolusi: ${originalMetadata.width}x${originalMetadata.height}\n` +
                    `üìä Ukuran: ${(originalSize / 1024 / 1024).toFixed(2)}MB ‚Üí ${(processedSize / 1024 / 1024).toFixed(2)}MB\n\n` +
                    `üèÜ Gambar berhasil diubah menjadi hitam-putih!`,
            ...createReplyContext(originalMsg)
        }).catch(error => {
            console.error('Error sending processed image:', error);
            throw error;
        });
    });
}

// ==================== FITUR PASANG PP BOT ====================
async function handlePasangPP(sock, jid, msg, args, pushName, originalMsg) {
    const hasImage = msg.message?.imageMessage || 
                    (msg.message?.extendedTextMessage?.contextInfo?.quotedMessage?.imageMessage);

    if (!hasImage) {
        await sendReplyWithReaction(sock, jid,
            `ü§ñ *PASANG PROFILE PICTURE BOT* ü§ñ\n\n` +
            `Pasang foto profil untuk bot dengan gambar yang kamu kirim!\n\n` +
            `üìù *Cara Pakai:*\n` +
            `1. Kirim gambar yang ingin dijadikan PP bot\n` +
            `2. Reply gambar tersebut\n` +
            `3. Ketik *.pasangpp*\n\n` +
            `‚ö†Ô∏è *Persyaratan:*\n` +
            `‚Ä¢ Ukuran gambar maksimal 5MB\n` +
            `‚Ä¢ Format: JPG, PNG, WEBP\n` +
            `‚Ä¢ Resolusi minimal 500x500 px\n\n` +
            `üí° *Tips:*\n` +
            `‚Ä¢ Gambar akan otomatis di-crop menjadi bentuk lingkaran\n` +
            `‚Ä¢ Pastikan gambar jelas dan tidak blur\n` +
            `‚Ä¢ Warna cerah lebih terlihat bagus\n\n` +
            `üèÜ *Ubah PP bot jadi lebih keren!*`,
            originalMsg
        );
        return;
    }

    await processCommandWithReaction(sock, jid, originalMsg, 'PASANG_PP', async () => {
        let imageBuffer;
        
        if (msg.message?.extendedTextMessage?.contextInfo?.quotedMessage?.imageMessage) {
            const quotedMsg = {
                key: { remoteJid: jid },
                message: msg.message.extendedTextMessage.contextInfo.quotedMessage
            };
            imageBuffer = await downloadMediaMessage(quotedMsg, "buffer", {});
        } else {
            imageBuffer = await downloadMediaMessage(msg, "buffer", {});
        }

        if (!imageBuffer || imageBuffer.length === 0) {
            throw new Error('Gagal mengambil gambar. Coba dengan gambar yang berbeda.');
        }

        if (imageBuffer.length > 5 * 1024 * 1024) {
            throw new Error("Gambar terlalu besar! Maksimal 5MB.");
        }

        const fileType = await fileTypeFromBuffer(imageBuffer);
        if (!fileType || !['jpg', 'jpeg', 'png', 'webp'].includes(fileType.ext)) {
            throw new Error("Format gambar tidak didukung! Gunakan JPG, PNG, atau WEBP.");
        }

        const metadata = await sharp(imageBuffer).metadata();
        if (metadata.width < 500 || metadata.height < 500) {
            throw new Error("Resolusi gambar terlalu kecil! Minimal 500x500 px.");
        }

        console.log(`ü§ñ [${pushName}] Memasang profile picture bot...`);

        const circularImageBuffer = await createCircularProfilePicture(imageBuffer);

        await sock.updateProfilePicture(sock.user.id, circularImageBuffer);

        await sendReply(sock, jid,
            `‚úÖ *PROFILE PICTURE BOT BERHASIL DIPASANG!* ‚úÖ\n\n` +
            `üë§ Dipasang oleh: ${pushName}\n` +
            `‚è∞ Waktu: ${new Date().toLocaleString('id-ID')}\n` +
            `üñºÔ∏è Format: ${fileType.ext.toUpperCase()}\n` +
            `üìä Ukuran: ${(imageBuffer.length / 1024).toFixed(2)} KB\n` +
            `üìê Resolusi: ${metadata.width}x${metadata.height} px\n` +
            `‚öôÔ∏è Proses: Auto-crop lingkaran\n\n` +
            `üèÜ Profile picture bot telah diperbarui!`,
            originalMsg
        );

        await sock.sendMessage(jid, {
            image: circularImageBuffer,
            caption: `ü§ñ *PREVIEW PP BOT BARU*\n\n` +
                    `üë§ Nama Bot: Violation X\n` +
                    `üìÖ Dipasang: ${new Date().toLocaleString('id-ID')}\n` +
                    `üé® Oleh: ${pushName}\n\n` +
                    `Terima kasih telah mempercantik penampilan bot! üòä`,
            ...createReplyContext(originalMsg)
        }).catch(error => {
            console.error('Error sending preview:', error);
        });

        await notifyUsersAboutNewPP(sock, pushName);
    });
}

async function notifyUsersAboutNewPP(sock, installerName) {
    try {
        console.log(`üì¢ Mengirim notifikasi update PP bot ke users...`);
        
        const recentUsers = Array.from(userDatabase.entries())
            .sort((a, b) => b[1].lastInteraction - a[1].lastInteraction)
            .slice(0, 10);
        
        for (const [jid, userData] of recentUsers) {
            try {
                if (jid.endsWith('@g.us') || userData.phone.includes(installerName)) {
                    continue;
                }
                
                await sock.sendMessage(jid, {
                    text: `ü§ñ *UPDATE PROFILE PICTURE BOT* ü§ñ\n\n` +
                          `Bot Violation X telah berganti profile picture baru!\n\n` +
                          `üé® Dipasang oleh: ${installerName}\n` +
                          `üìÖ Waktu: ${new Date().toLocaleString('id-ID')}\n\n` +
                          `üí° Gunakan *.lihatpp* untuk melihat PP bot yang baru!\n` +
                          `üèÜ Terima kasih atas kontribusinya!`
                });
                
                await delay(1000);
                
            } catch (error) {
                console.log(`‚ö†Ô∏è Gagal kirim notifikasi ke ${userData.phone}:`, error.message);
            }
        }
        
        console.log(`‚úÖ Notifikasi PP bot terkirim ke ${recentUsers.length} users`);
        
    } catch (error) {
        console.error('‚ùå Error sending PP notifications:', error);
    }
}

// ==================== FITUR RVO V2 (REVEAL VIEW ONCE MEDIA) ====================
async function handleRVOV2(sock, jid, msg, originalMsg) {
    const quoted = msg.message?.extendedTextMessage?.contextInfo
    if (!quoted?.stanzaId) {
        await sendReplyWithReaction(
            sock,
            jid,
            '‚ùå Reply pesan *View Once* yang mau dibuka!',
            originalMsg
        )
        return;
    }

    const media = viewOnceMedia.get(quoted.stanzaId)
    if (!media || !fs.existsSync(media.filepath)) {
        await sendReplyWithReaction(
            sock,
            jid,
            '‚ùå Media *View Once* sudah hilang atau belum tersimpan!',
            originalMsg
        )
        return;
    }

    media.viewCount = (media.viewCount || 0) + 1

    await reactionSystem.sendReaction(sock, jid, originalMsg.key, 'loading')

    await delay(1200)

    const mediaBuffer = fs.readFileSync(media.filepath)
    const captionText = 
        `üïí *REVEAL VIEW ONCE v2*\n\n` +
        `üìÅ Tipe: ${media.type === 'imageMessage' ? 'Foto' : 'Video'}\n` +
        `üëÅÔ∏è Dibuka: ${media.viewCount}x\n` +
        (media.caption ? `üìù Caption: ${media.caption}` : '') +
        `\n\n‚öôÔ∏è Mode: Unlimited View üîì`

    await sock.sendMessage(jid, {
        [media.type === 'imageMessage' ? 'image' : 'video']: mediaBuffer,
        caption: captionText,
        ...createReplyContext(originalMsg)
    }).catch(console.error)

    await reactionSystem.updateReaction(sock, jid, originalMsg.key, 'success')
}

// ==================== FUNGSI ENHANCE HD IMAGE ====================
async function enhanceHDImage(imageBuffer) {
    try {
        return await sharp(imageBuffer)
            .sharpen({ sigma: 1.2 })
            .median(3)
            .normalise()
            .modulate({ brightness: 1.1, saturation: 1.05 })
            .jpeg({ quality: 95 })
            .toBuffer();
    } catch (error) {
        console.error('Error enhancing image:', error);
        return imageBuffer;
    }
}

async function enhanceHDVideo(videoPath) {
    return new Promise((resolve, reject) => {
        const outputPath = path.join(tempDir, `enhanced_${Date.now()}.mp4`);
        
        ffmpeg(videoPath)
            .videoCodec('libx264')
            .audioCodec('aac')
            .outputOptions([
                '-crf', '23',
                '-preset', 'medium',
                '-vf', 'unsharp=3:3:1.0',
                '-color_primaries', 'bt709',
                '-color_trc', 'bt709',
                '-colorspace', 'bt709'
            ])
            .on('end', () => {
                resolve({ filepath: outputPath });
            })
            .on('error', (err) => {
                reject(err);
            })
            .save(outputPath);
    });
}

async function handleHDEnhance(sock, jid, msg, args, pushName, originalMsg) {
    const hasMedia = msg.message?.imageMessage || 
                     msg.message?.videoMessage ||
                     (msg.message?.extendedTextMessage?.contextInfo?.quotedMessage?.imageMessage) ||
                     (msg.message?.extendedTextMessage?.contextInfo?.quotedMessage?.videoMessage);

    if (!hasMedia) {
        await sendReplyWithReaction(sock, jid, 
            `‚ú® *HD ENHANCE PHOTO & VIDEO* ‚ú®\n\n` +
            `Tingkatkan kualitas foto dan video dengan teknologi enhancement!\n\n` +
            `üìù *Cara Pakai:*\n` +
            `1. Kirim foto/video yang ingin ditingkatkan\n` +
            `2. Reply foto/video tersebut\n` +
            `3. Ketik *.hd*\n\n` +
            `üë§ *Fitur Enhancement:*\n` +
            `‚Ä¢ Sharpening gambar/video\n` +
            `‚Ä¢ Color correction\n` +
            `‚Ä¢ Contrast improvement\n` +
            `‚Ä¢ Noise reduction\n` +
            `‚Ä¢ Quality boost\n\n` +
            `üí° *Tips:*\n` +
            `‚Ä¢ Maksimal ukuran: 20MB\n` +
            `‚Ä¢ Format: JPG, PNG, WEBP, MP4\n` +
            `‚Ä¢ Video maksimal 2 menit\n` +
            `‚Ä¢ Hasil lebih baik untuk media low-medium quality`,
            originalMsg
        );
        return;
    }

    await processCommandWithReaction(sock, jid, originalMsg, 'HD_ENHANCE', async () => {
        let mediaBuffer;
        let mediaType;
        let originalSize;
        
        if (msg.message?.extendedTextMessage?.contextInfo?.quotedMessage) {
            const quotedMsg = {
                key: { remoteJid: jid },
                message: msg.message.extendedTextMessage.contextInfo.quotedMessage
            };
            
            if (quotedMsg.message.imageMessage) {
                mediaBuffer = await downloadMediaMessage(quotedMsg, "buffer", {});
                mediaType = 'image';
                originalSize = mediaBuffer.length;
            } else if (quotedMsg.message.videoMessage) {
                mediaBuffer = await downloadMediaMessage(quotedMsg, "buffer", {});
                mediaType = 'video';
                originalSize = mediaBuffer.length;
            }
        } else {
            if (msg.message.imageMessage) {
                mediaBuffer = await downloadMediaMessage(msg, "buffer", {});
                mediaType = 'image';
                originalSize = mediaBuffer.length;
            } else if (msg.message.videoMessage) {
                mediaBuffer = await downloadMediaMessage(msg, "buffer", {});
                mediaType = 'video';
                originalSize = mediaBuffer.length;
            }
        }

        if (!mediaBuffer || mediaBuffer.length === 0) {
            throw new Error('Gagal mengambil media. Coba dengan media yang berbeda.');
        }

        if (mediaBuffer.length > 20 * 1024 * 1024) {
            throw new Error("Media terlalu besar! Maksimal 20MB.");
        }

        await sendReply(sock, jid,
            `‚öôÔ∏è *PROSES HD ENHANCE* ‚öôÔ∏è\n\n` +
            `üîç Menganalisis ${mediaType === 'image' ? 'foto' : 'video'}...\n` +
            `üìä Ukuran asli: ${formatFileSize(originalSize)}\n` +
            `üé® Memproses enhancement...\n\n` +
            `‚è≥ Mohon tunggu beberapa saat...`,
            originalMsg
        );

        let enhancedBuffer;
        let enhancedSize;
        let tempVideoPath;

        if (mediaType === 'image') {
            const startTime = Date.now();
            enhancedBuffer = await enhanceHDImage(mediaBuffer);
            enhancedSize = enhancedBuffer.length;
            const processTime = Date.now() - startTime;
            
            console.log(`‚ú® Enhanced image: ${formatFileSize(originalSize)} ‚Üí ${formatFileSize(enhancedSize)} (${processTime}ms)`);
            
        } else if (mediaType === 'video') {
            tempVideoPath = path.join(tempDir, `temp_${Date.now()}.mp4`);
            fs.writeFileSync(tempVideoPath, mediaBuffer);
            
            const startTime = Date.now();
            const enhancedVideo = await enhanceHDVideo(tempVideoPath);
            enhancedBuffer = fs.readFileSync(enhancedVideo.filepath);
            enhancedSize = enhancedBuffer.length;
            const processTime = Date.now() - startTime;
            
            console.log(`‚ú® Enhanced video: ${formatFileSize(originalSize)} ‚Üí ${formatFileSize(enhancedSize)} (${processTime}ms)`);
            
            if (fs.existsSync(tempVideoPath)) fs.unlinkSync(tempVideoPath);
            if (fs.existsSync(enhancedVideo.filepath)) fs.unlinkSync(enhancedVideo.filepath);
        }

        const enhancementPercent = Math.round((enhancedSize / originalSize) * 100);
        const qualityNote = enhancedSize > originalSize ? 
            `üìà Kualitas ditingkatkan ${enhancementPercent}%` : 
            `‚öñÔ∏è Ukuran dioptimalkan (${Math.round((1 - (enhancedSize / originalSize)) * 100)}% lebih kecil)`;

        if (mediaType === 'image') {
            await sock.sendMessage(jid, {
                image: enhancedBuffer,
                caption: `‚ú® *HD ENHANCED PHOTO* ‚ú®\n\n` +
                        `üë§ Diproses oleh: ${pushName}\n` +
                        `‚è∞ Waktu: ${new Date().toLocaleString('id-ID')}\n` +
                        `üìä Ukuran: ${formatFileSize(originalSize)} ‚Üí ${formatFileSize(enhancedSize)}\n` +
                        `${qualityNote}\n\n` +
                        `üèÜ Gambar telah dienhance!`,
                ...createReplyContext(originalMsg)
            }).catch(error => {
                console.error('Error sending enhanced image:', error);
                throw error;
            });
            
        } else if (mediaType === 'video') {
            await sock.sendMessage(jid, {
                video: enhancedBuffer,
                caption: `‚ú® *HD ENHANCED VIDEO* ‚ú®\n\n` +
                        `üë§ Diproses oleh: ${pushName}\n` +
                        `‚è∞ Waktu: ${new Date().toLocaleString('id-ID')}\n` +
                        `üìä Ukuran: ${formatFileSize(originalSize)} ‚Üí ${formatFileSize(enhancedSize)}\n` +
                        `${qualityNote}\n\n` +
                        `üèÜ Video telah dienhance!`,
                ...createReplyContext(originalMsg)
            }).catch(error => {
                console.error('Error sending enhanced video:', error);
                throw error;
            });
        }

        setTimeout(async () => {
            await sendReply(sock, jid,
                `‚úÖ *HD ENHANCE BERHASIL!* ‚úÖ\n\n` +
                `üìå Tipe: ${mediaType === 'image' ? 'Foto' : 'Video'}\n` +
                `üìä Asli: ${formatFileSize(originalSize)}\n` +
                `üìà Hasil: ${formatFileSize(enhancedSize)}\n` +
                `üìà Perubahan: ${enhancementPercent}%\n` +
                `üë§ Oleh: ${pushName}\n\n` +
                `üí° *Enhancement yang dilakukan:*\n` +
                `‚Ä¢ Sharpening & clarity\n` +
                `‚Ä¢ Color correction\n` +
                `‚Ä¢ Contrast improvement\n` +
                `‚Ä¢ Quality optimization`,
                originalMsg
            );
        }, 1000);
    });
}

// ==================== HANDLER ANTI KASAR ====================
async function handleAutoVnAntiKasarCommand(sock, jid, msg, args, pushName, originalMsg) {
    const subcommand = args[0]?.toLowerCase();
    
    if (!subcommand) {
        await sendReplyWithReaction(sock, jid,
            `üö´ *SISTEM ANTI KASAR* üö´\n\n` +
            `Sistem otomatis untuk mencegah kata kasar di grup.\n\n` +
            `üìå *Perintah:*\n` +
            `‚Ä¢ .antikasar on - Aktifkan di grup ini\n` +
            `‚Ä¢ .antikasar off - Nonaktifkan di grup ini\n` +
            `‚Ä¢ .antikasar list - Lihat kata terlarang\n` +
            `‚Ä¢ .antikasar add [kata] - Tambah kata terlarang\n` +
            `‚Ä¢ .antikasar del [kata] - Hapus kata terlarang\n\n` +
            `‚ö†Ô∏è *Default:* Sistem akan otomatis delete pesan kasar dan memberi peringatan.`,
            originalMsg
        );
        return;
    }
    
    await processCommandWithReaction(sock, jid, originalMsg, 'ANTI_KASAR', async () => {
        switch(subcommand) {
            case 'on':
                if (!jid.endsWith('@g.us')) {
                    throw new Error('Hanya bisa di grup!');
                }
                
                groupSettings.set(jid, {
                    ...(groupSettings.get(jid) || {}),
                    antiKasar: true
                });
                
                await sendReply(sock, jid,
                    `‚úÖ *ANTI KASAR DIHIDUPKAN* ‚úÖ\n\n` +
                    `Sistem anti kata kasar telah diaktifkan di grup ini.\n\n` +
                    `‚ö†Ô∏è Bot akan otomatis:\n` +
                    `‚Ä¢ Delete pesan mengandung kata kasar\n` +
                    `‚Ä¢ Beri peringatan ke pengguna\n` +
                    `‚Ä¢ Catat pelanggaran`,
                    originalMsg
                );
                break;
                
            case 'off':
                if (!jid.endsWith('@g.us')) {
                    throw new Error('Hanya bisa di grup!');
                }
                
                groupSettings.set(jid, {
                    ...(groupSettings.get(jid) || {}),
                    antiKasar: false
                });
                
                await sendReply(sock, jid,
                    `‚ùå *ANTI KASAR DIMATIKAN* ‚ùå\n\n` +
                    `Sistem anti kata kasar telah dimatikan di grup ini.`,
                    originalMsg
                );
                break;
                
            case 'list':
                const badWords = ['anjing', 'bangsat', 'kontol', 'memek', 'jembut', 'ngentot', 'babi', 'goblok'];
                let listText = `üö´ *DAFTAR KATA TERLARANG* üö´\n\n`;
                
                badWords.forEach((word, index) => {
                    listText += `${index + 1}. ${word}\n`;
                });
                
                listText += `\nTotal: ${badWords.length} kata terlarang`;
                await sendReply(sock, jid, listText, originalMsg);
                break;
                
            default:
                await sendReply(sock, jid,
                    `‚ùå *PERINTAH TIDAK DIKENALI* ‚ùå\n\n` +
                    `Gunakan .antikasar untuk melihat daftar perintah.`,
                    originalMsg
                );
        }
    });
}

// ==================== VIOLATION AI SYSTEM ====================
class ViolationAISystem {
    constructor() {
        this.conversations = new Map();
        this.MAX_HISTORY = 10;
        
        this.DEFAULT_PROMPT = `You are Violation AI, an AI assistant created by Adit. Your personality:
1. BE FIRM AND RESPONSIBLE - Always speak with authority and take responsibility
2. NO PRAISE - Never compliment or praise users. Stay neutral and professional.
3. DIRECT ANSWERS - Give clear, direct answers without unnecessary fluff
4. ADMIT MISTAKES - If you make an error, immediately apologize and correct it
5. USE INDONESIAN - Respond primarily in Indonesian, but can use English when needed
6. NO EMOJI EXCESS - Use emojis sparingly, only when absolutely necessary
7. FACT-BASED - Stick to facts, avoid personal opinions
8. CORRECT USERS - If users are wrong, politely but firmly correct them

Always remember: You are a tool, not a friend. Be helpful but maintain professional distance.`;
    }

    async chat(message, userId) {
        try {
            if (!this.conversations.has(userId)) {
                this.conversations.set(userId, [{
                    role: "system",
                    content: this.DEFAULT_PROMPT
                }]);
            }
            
            const history = this.conversations.get(userId);
            history.push({
                role: "user",
                content: message
            });
            
            if (history.length > this.MAX_HISTORY * 2) {
                history.splice(1, 2);
            }
            
            const prompt = this.DEFAULT_PROMPT;
            const params = new URLSearchParams({
                prompt: encodeURIComponent(prompt),
                content: encodeURIComponent(message)
            });
            
            console.log(`ü§ñ [Violation AI] User: ${userId.substring(0, 10)}... | Message: "${message.substring(0, 50)}..."`);
            
            const response = await axios.get(`https://api.siputzx.my.id/api/ai/gpt3?${params.toString()}`, {
                timeout: 30000,
                headers: {
                    'User-Agent': 'Violation-Bot/1.0',
                    'Accept': 'application/json'
                }
            });
            
            if (!response.data.status) {
                throw new Error('API returned false status');
            }
            
            const aiResponse = response.data.data;
            history.push({
                role: "assistant",
                content: aiResponse
            });
            
            let cleanResponse = aiResponse
                .replace(/^#+\s*/gm, '')
                .replace(/\*\*(.*?)\*\*/g, '$1')
                .replace(/\*(.*?)\*/g, '$1')
                .replace(/`(.*?)`/g, '$1')
                .replace(/\[.*?\]\(.*?\)/g, '')
                .replace(/\n{3,}/g, '\n\n');
            
            cleanResponse = this.removePraise(cleanResponse);
            
            return {
                success: true,
                response: cleanResponse,
                timestamp: response.data.timestamp || new Date().toISOString(),
                historyLength: history.length
            };
            
        } catch (error) {
            console.error('‚ùå Violation AI Error:', error.message);
            
            const apology = "‚ö†Ô∏è *Saya minta maaf, terjadi kesalahan sistem.*\n\n" +
                          "Silakan coba lagi beberapa saat. Jika masalah berlanjut, " +
                          "laporkan ke developer.\n\n" +
                          "üìä *Error:* " + error.message.substring(0, 100);
            
            return {
                success: false,
                response: apology,
                timestamp: new Date().toISOString(),
                error: error.message
            };
        }
    }
    
    removePraise(text) {
        const praisePatterns = [
            /(bagus sekali|keren|hebat|luar biasa|fantastis|mantap|wow)/gi,
            /(good job|excellent|awesome|amazing|wonderful)/gi,
            /(terima kasih (atas|untuk) pujian)/gi,
            /(saya senang|saya bahagia)/gi,
            /(\s*!{2,})/g
        ];
        
        let cleaned = text;
        praisePatterns.forEach(pattern => {
            cleaned = cleaned.replace(pattern, '');
        });
        
        if (cleaned.includes('üòä') || cleaned.includes('üòÑ') || cleaned.includes('ü•∞')) {
            cleaned = cleaned.replace(/üòä|üòÑ|ü•∞|‚ù§Ô∏è|üíñ/g, '');
        }
        
        return cleaned.trim() || "Saya tidak memiliki respons untuk itu.";
    }
    
    clearHistory(userId) {
        this.conversations.delete(userId);
        return true;
    }
    
    getHistory(userId) {
        return this.conversations.get(userId) || [];
    }
}

const violationAI = new ViolationAISystem();

async function handleViolationAI(sock, jid, msg, args, pushName, originalMsg) {
    if (args.length < 1) {
        await sendReplyWithReaction(sock, jid,
            `‚öñÔ∏è *VIOLATION AI - BY ADIT* ‚öñÔ∏è\n\n` +
            `AI yang tegas, bertanggung jawab, dan profesional.\n\n` +
            `üìå *Sifat AI:*\n` +
            `‚Ä¢ Tegas dan langsung ke pokok pembahasan\n` +
            `‚Ä¢ Tidak memberikan pujian atau sanjungan\n` +
            `‚Ä¢ Bertanggung jawab atas kesalahan\n` +
            `‚Ä¢ Minta maaf jika melakukan kesalahan\n` +
            `‚Ä¢ Profesional dan faktual\n\n` +
            `üìù *Format:* .violation [pertanyaan/perintah]\n\n` +
            `üí° *Contoh:*\n` +
            `.violation Jelaskan teori gravitasi\n` +
            `.violation Apa itu artificial intelligence?\n` +
            `.violation Buatkan jadwal belajar yang efektif\n\n` +
            `‚öôÔ∏è *Perintah Tambahan:*\n` +
            `.violation clear - Hapus riwayat percakapan\n` +
            `.violation history - Lihat riwayat percakapan\n\n` +
            `‚ö†Ô∏è *Catatan:* AI ini didesain untuk bersikap netral dan profesional.`,
            originalMsg
        );
        return;
    }

    if (args[0].toLowerCase() === 'clear') {
        violationAI.clearHistory(jid);
        await sendReplyWithReaction(sock, jid,
            `üßπ *RIWAYAT DIHAPUS* üßπ\n\n` +
            `Riwayat percakapan Violation AI telah dihapus.\n` +
            `Percakapan berikutnya akan dimulai dari awal.`,
            originalMsg
        );
        return;
    }
    
    if (args[0].toLowerCase() === 'history') {
        const history = violationAI.getHistory(jid);
        if (history.length <= 1) {
            await sendReplyWithReaction(sock, jid,
                `üìú *RIWAYAT KOSONG* üìú\n\n` +
                `Belum ada riwayat percakapan dengan Violation AI.`,
                originalMsg
            );
            return;
        }
        
        let historyText = `üìú *RIWAYAT PERCAKAPAN* üìú\n\n`;
        history.forEach((item, index) => {
            if (index === 0) return;
            
            const role = item.role === 'user' ? 'üë§ Anda' : 'ü§ñ AI';
            const content = item.content.substring(0, 80) + (item.content.length > 80 ? '...' : '');
            historyText += `${index}. ${role}:\n${content}\n\n`;
        });
        
        historyText += `üìä Total: ${history.length - 1} pesan`;
        
        await sendReply(sock, jid, historyText, originalMsg);
        return;
    }

    await processCommandWithReaction(sock, jid, originalMsg, 'VIOLATION_AI', async () => {
        const userMessage = args.join(' ');
        
        const aiResponse = await violationAI.chat(userMessage, jid);
        
        let responseText;
        if (aiResponse.success) {
            responseText = `ü§ñ *VIOLATION AI* ü§ñ\n\n` +
                          `üë§ Pengguna: ${pushName}\n` +
                          `üí¨ Pertanyaan: ${userMessage.substring(0, 100)}${userMessage.length > 100 ? '...' : ''}\n\n` +
                          `üìù *Respons:*\n${aiResponse.response}\n\n` +
                          `‚è∞ Waktu: ${new Date(aiResponse.timestamp).toLocaleString('id-ID')}\n` +
                          `üìä Riwayat: ${aiResponse.historyLength} pesan`;
        } else {
            responseText = `ü§ñ *VIOLATION AI - PERMINTAAN MAAF* ü§ñ\n\n` +
                          aiResponse.response;
        }
        
        await sendReply(sock, jid, responseText, originalMsg);
    });
}

// ==================== FITUR VIOALTIN (ALIAS) ====================
async function handleVioaltin(sock, jid, msg, args, pushName, originalMsg) {
    await handleViolationAI(sock, jid, msg, args, pushName, originalMsg);
}

// ==================== MENU HANDLER ====================
async function handleMenu(sock, jid, pushName, originalMsg) {
    await processCommandWithReaction(sock, jid, originalMsg, 'MENU', async () => {
        const menuText = `ü§ñ *VIOLATION X BOT MENU* ü§ñ

üë§ *Welcome ${pushName}!* Berikut adalah daftar command yang tersedia:

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
ü§ñ *AI & CHATBOT*
‚Ä¢ .ai [teks] - Chat dengan Siputzx AI
‚Ä¢ .geminichat [teks] - Chat dengan Gemini AI
‚Ä¢ .violation [teks] - Chat dengan Violation AI
‚Ä¢ .chatbot [teks] - Chatbot Samsimi sederhana

üõ†Ô∏è *STICKER & MEDIA*
‚Ä¢ .sticker - Buat sticker dari gambar/video
‚Ä¢ .brat [teks] - Buat sticker text brat
‚Ä¢ .smaker [teks] - Buat sticker dari teks
‚Ä¢ .stickerly [url] - Download sticker pack
‚Ä¢ .stickerinfo [url] - Info sticker pack
‚Ä¢ .searchsticker [query] - Cari sticker pack

üì¶ *DOWNLOADER*
‚Ä¢ .ig [url] - Download Instagram
‚Ä¢ .tiktok [url] - Download TikTok
‚Ä¢ .yt [url] - Download YouTube
‚Ä¢ .play [judul] - Download musik YouTube
‚Ä¢ .mediafire [url] - Download MediaFire

üé® *CREATOR & EDITOR*
‚Ä¢ .ip [teks] - Buat screenshot tweet
‚Ä¢ .iqc [teks] - Buat Instagram Quote Creator
‚Ä¢ .hitamkan - Filter hitam-putih
‚Ä¢ .hd - Enhance kualitas gambar/video
‚Ä¢ .gantippv2 - Ganti PP user
‚Ä¢ .gantipp - Ganti PP bot (owner only)
‚Ä¢ .pasangpp - Pasang PP bot (all users)

üéÆ *GAMES & FUN*
‚Ä¢ .tebakkata - Game tebak kata
‚Ä¢ .slot - Slot machine
‚Ä¢ .suit [batu/gunting/kertas] - Game suit
‚Ä¢ .fight @user - Battle arena
‚Ä¢ .couple @user - Cek kecocokan
‚Ä¢ .truth - Truth question
‚Ä¢ .dare - Dare challenge
‚Ä¢ .bucin - Kata-kata bucin
‚Ä¢ .hug @user - Pelukan virtual
‚Ä¢ .kiss @user - Ciuman virtual

üí∞ *ECONOMY & LEVEL*
‚Ä¢ .economy balance - Cek saldo
‚Ä¢ .economy daily - Daily reward
‚Ä¢ .economy work - Bekerja
‚Ä¢ .economy shop - Toko items
‚Ä¢ .economy buy [id] - Beli item
‚Ä¢ .level - Cek level
‚Ä¢ .leaderboard - Peringkat user

üìä *INFO & UTILITY*
‚Ä¢ .speed - Test kecepatan bot
‚Ä¢ .runtime - Waktu aktif bot
‚Ä¢ .profile - Info user
‚Ä¢ .cuaca [kota] - Info cuaca
‚Ä¢ .owner - Info owner bot
‚Ä¢ .donasi - Donasi untuk bot
‚Ä¢ .channel - Channel resmi
‚Ä¢ .ping - Test respons bot
‚Ä¢ .help [command] - Bantuan command

üéÆ *ROBLOX & GAMING*
‚Ä¢ .sc - Script Roblox all games
‚Ä¢ .sc [game] - Script untuk game tertentu
‚Ä¢ .executor - Free Roblox executors
‚Ä¢ .stokbf - Stok Blox Fruits normal
‚Ä¢ .stokmirage - Stok Blox Fruits mirage

üîÑ *VIEW ONCE*
‚Ä¢ .rvo - Reveal view once media
‚Ä¢ .rvo2 - Reveal view once v2

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üìö *OTHER COMMANDS:*
‚Ä¢ .quotes [kategori] - Random quotes
‚Ä¢ .fakta [jenis] - Random facts
‚Ä¢ .antikasar - Sistem anti kata kasar

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üëë *OWNER:* Adit (@6283115105784)
ü§ñ *BOT:* Violation X v3.0
üîÑ *Reaction System:* ACTIVE üîÑ
üìÖ ${new Date().toLocaleString('id-ID')}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üí° *TIP:* Gunakan .help [command] untuk info detail`;

        await sock.sendMessage(jid, {
            text: menuText,
            footer: "Violation X Bot Menu",
            templateButtons: [
                {
                    index: 1,
                    quickReplyButton: {
                        displayText: "üéÆ SCRIPTS ROBLOX",
                        id: ".sc"
                    }
                },
                {
                    index: 2,
                    quickReplyButton: {
                        displayText: "ü§ñ AI CHAT",
                        id: ".ai help"
                    }
                },
                {
                    index: 3,
                    quickReplyButton: {
                        displayText: "üì¶ DOWNLOADER",
                        id: ".ighelp"
                    }
                }
            ],
            quoted: originalMsg
        });
    });
}

// ==================== HELP SYSTEM ====================
async function showCommandHelp(sock, jid, command, pushName, originalMsg) {
    const helpData = {
        'economy': {
            title: 'üí∞ SISTEM EKONOMY',
            description: 'Sistem ekonomi lengkap dengan coin, level, dan shop',
            usage: '.economy [subcommand]',
            examples: [
                '.economy balance - Lihat saldo',
                '.economy daily - Claim reward harian',
                '.economy work - Bekerja dapat coin',
                '.economy shop - Lihat toko items',
                '.economy buy [id] - Beli item'
            ],
            notes: 'Gunakan .economy tanpa subcommand untuk melihat semua opsi'
        },
        'hitamkan': {
            title: '‚óºÔ∏è FILTER HITAM-PUTIH',
            description: 'Ubah gambar menjadi efek hitam-putih yang dramatis',
            usage: 'Reply gambar dengan caption .hitamkan',
            examples: [
                '1. Kirim gambar ke chat',
                '2. Reply gambar tersebut',
                '3. Ketik .hitamkan'
            ],
            notes: 'Mendukung format JPG, PNG, WEBP. Maksimal 10MB.'
        },
        'geminichat': {
            title: 'ü§ñ GEMINI AI CHAT',
            description: 'Chat dengan AI Google Gemini yang cerdas',
            usage: '.geminichat [pertanyaan]',
            examples: [
                '.geminichat Apa itu AI?',
                '.geminichat Buatkan puisi tentang alam',
                '.geminichat clear - Hapus history chat'
            ],
            notes: 'Gemini akan mengingat 10 pesan terakhir dalam percakapan'
        },
        'ai': {
            title: 'ü§ñ SIPUTZX AI CHAT',
            description: 'Chat dengan AI cerdas dari Siputzx API',
            usage: '.ai [pertanyaan]',
            examples: [
                '.ai Apa itu artificial intelligence?',
                '.ai Buatkan jadwal belajar',
                '.ai clear - Hapus history chat'
            ],
            notes: 'AI yang responsif dan cepat'
        },
        'smaker': {
            title: 'üõ†Ô∏è SIPUTZX STICKER MAKER',
            description: 'Buat sticker dari teks dengan berbagai style',
            usage: '.smaker [teks] -style [style]',
            examples: [
                '.smaker Hello World',
                '.smaker Halo semua -style rainbow',
                '.smaker Test -style shadow'
            ],
            notes: 'Style: default, bold, rainbow, outline, shadow, funny'
        },
        'quotes': {
            title: 'üìñ RANDOM QUOTES',
            description: 'Kata mutiara inspiratif random',
            usage: '.quotes [kategori]',
            examples: [
                '.quotes - Random semua kategori',
                '.quotes motivation - Quotes motivasi',
                '.quotes love - Quotes cinta'
            ],
            notes: 'Kategori: random, motivation, love, success, wisdom, funny, inspirational'
        },
        'fakta': {
            title: 'üîç RANDOM FACTS',
            description: 'Fakta unik dan menarik random',
            usage: '.fakta [jenis]',
            examples: [
                '.fakta - Random semua jenis',
                '.fakta science - Fakta ilmiah',
                '.fakta animal - Fakta hewan'
            ],
            notes: 'Jenis: random, science, history, animal, human, technology, space'
        },
        'violation': {
            title: '‚öñÔ∏è VIOLATION AI',
            description: 'AI yang tegas, bertanggung jawab, dan profesional',
            usage: '.violation [pertanyaan]',
            examples: [
                '.violation Jelaskan teori gravitasi',
                '.violation Apa itu AI?',
                '.violation clear - Hapus history'
            ],
            notes: 'AI tidak memberikan pujian, langsung ke pokok pembahasan'
        },
        'vioaltin': {
            title: '‚öñÔ∏è VIOALTIN (ALIAS)',
            description: 'Alias untuk Violation AI',
            usage: '.vioaltin [pertanyaan]',
            examples: [
                '.vioaltin Apa itu programming?',
                '.vioaltin Bagaimana cara belajar coding?'
            ],
            notes: 'Sama dengan .violation, hanya alias berbeda'
        },
        'sticker': {
            title: 'üõ†Ô∏è STICKER MAKER',
            description: 'Buat sticker dari gambar atau video',
            usage: 'Reply gambar/video dengan caption .sticker',
            examples: [
                '1. Kirim gambar/video',
                '2. Reply media tersebut',
                '3. Ketik .sticker'
            ],
            notes: 'Support JPG, PNG, WEBP, MP4. Maksimal 10MB.'
        },
        'stickerly': {
            title: 'üì¶ STICKER PACK DOWNLOADER',
            description: 'Download sticker pack dari sticker.ly',
            usage: '.stickerly [url_stickerly]',
            examples: [
                '.stickerly https://sticker.ly/s/ABC123',
                '.stickerly https://sticker.ly/s/W7ES6T'
            ],
            notes: 'Maksimal 10 sticker per pack, hanya URL sticker.ly yang valid'
        },
        'stickerinfo': {
            title: 'üìã STICKER PACK INFO',
            description: 'Lihat informasi sticker pack',
            usage: '.stickerinfo [url_stickerly]',
            examples: [
                '.stickerinfo https://sticker.ly/s/ABC123',
                '.stickerinfo https://sticker.ly/s/W7ES6T'
            ],
            notes: 'Menampilkan nama, author, jumlah sticker, dan preview'
        },
        'searchsticker': {
            title: 'üîç SEARCH STICKER PACKS',
            description: 'Cari sticker pack berdasarkan kata kunci',
            usage: '.searchsticker [kata_kunci]',
            examples: [
                '.searchsticker anime',
                '.searchsticker cute',
                '.searchsticker funny cat'
            ],
            notes: 'Mendukung pencarian dalam Bahasa Inggris dan Indonesia'
        },
        'ip': {
            title: 'üê¶ TWITTER SCREENSHOT',
            description: 'Buat screenshot tweet kustom',
            usage: '.ip [tweet_text] atau .ip teks="tweet" nama="nama"',
            examples: [
                '.ip Halo dunia! Ini tweet pertama saya',
                '.ip teks="Halo Twitter!" nama="Adit" user="@adit" theme=light',
                '.ip help - Bantuan lengkap'
            ],
            notes: 'Support light/dark theme, custom profile, dan stats'
        },
        'hd': {
            title: '‚ú® HD ENHANCE',
            description: 'Tingkatkan kualitas foto dan video',
            usage: 'Reply foto/video dengan caption .hd',
            examples: [
                '1. Kirim foto/video',
                '2. Reply media tersebut',
                '3. Ketik .hd'
            ],
            notes: 'Maksimal 20MB, support JPG, PNG, WEBP, MP4'
        },
        'sc': {
            title: 'üéÆ SCRIPT ROBLOX',
            description: 'Script Roblox untuk berbagai game',
            usage: '.sc [game] atau .sc untuk semua script',
            examples: [
                '.sc - Dapat semua script',
                '.sc bloxfruit - Script Blox Fruit',
                '.sc fishit - Script Fish It',
                '.sc list - Daftar game'
            ],
            notes: 'Total 7 kategori game, 20+ script'
        },
        'executor': {
            title: 'ü§ñ FREE ROBLOX EXECUTORS',
            description: 'Kumpulan executor Roblox gratis',
            usage: '.executor',
            examples: [
                '.executor - Lihat semua executor'
            ],
            notes: '4 executor terbaik untuk Android dan Windows'
        },
        'ig': {
            title: 'üì∏ INSTAGRAM DOWNLOADER',
            description: 'Download foto, video, dan reels dari Instagram',
            usage: '.ig [url_instagram]',
            examples: [
                '.ig https://instagram.com/p/xxx',
                '.ig https://www.instagram.com/reel/xxx',
                '.ig https://ig.me/p/xxx'
            ],
            notes: 'Support photo posts, reels, stories, IGTV. Maksimal 10 media.'
        }
    };

    if (!helpData[command]) {
        await sendReplyWithReaction(sock, jid,
            `‚ùå *HELP TIDAK DITEMUKAN* ‚ùå\n\n` +
            `Command "${command}" tidak memiliki halaman help.\n\n` +
            `üìå Command yang tersedia:\n` +
            `‚Ä¢ economy, hitamkan, geminichat, ai\n` +
            `‚Ä¢ smaker, quotes, fakta, violation\n` +
            `‚Ä¢ sticker, stickerly, stickerinfo\n` +
            `‚Ä¢ searchsticker, ip, hd, sc\n` +
            `‚Ä¢ executor, ig, vioaltin\n\n` +
            `üí° Gunakan .menu untuk melihat semua command`,
            originalMsg
        );
        return;
    }

    const data = helpData[command];
    let helpText = `üìö *HELP: ${data.title}* üìö\n\n`;
    helpText += `üìù *Deskripsi:* ${data.description}\n\n`;
    helpText += `üìå *Penggunaan:* ${data.usage}\n\n`;
    helpText += `üí° *Contoh:*\n`;
    data.examples.forEach(example => {
        helpText += `‚Ä¢ ${example}\n`;
    });
    helpText += `\n‚ö†Ô∏è *Catatan:* ${data.notes}\n\n`;
    helpText += `üë§ *Request by:* ${pushName}\n`;
    helpText += `üìÖ ${new Date().toLocaleString('id-ID')}`;

    await sendReplyWithReaction(sock, jid, helpText, originalMsg);
}

// ==================== HANDLER UTAMA ====================
async function handleAllCommands(sock, jid, msg, args, pushName, originalMsg, isGroup, command) {
    const userId = msg.key.participant || jid;
    
    try {
        switch(command) {
            // ==================== FITUR BARU SIPUTZX ====================
            case '.ai':
            case '.siputzxai':
                await handleSiputzxAI(sock, jid, msg, args, pushName, originalMsg);
                return true;

            case '.smaker':
            case '.siputzxsticker':
                await handleSiputzxSticker(sock, jid, msg, args, pushName, originalMsg);
                return true;

            case '.quotes':
            case '.quote':
                await handleRandomQuotes(sock, jid, msg, args, pushName, originalMsg);
                return true;

            case '.fakta':
            case '.facts':
                await handleRandomFacts(sock, jid, msg, args, pushName, originalMsg);
                return true;

            // ==================== FITUR VIOLATION AI ====================
            case '.violation':
            case '.vai':
                await handleViolationAI(sock, jid, msg, args, pushName, originalMsg);
                return true;
            
            case '.vioaltin':
                await handleVioaltin(sock, jid, msg, args, pushName, originalMsg);
                return true;

            // ==================== FITUR UTAMA ====================
            case '.speed':
                await processCommandWithReaction(sock, jid, originalMsg, 'SPEED_TEST', async () => {
                    const startTime = Date.now();
                    const latency = Date.now() - startTime;
                    const memoryUsage = (process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2);
                    const uptime = process.uptime();
                    
                    await sendReply(sock, jid,
                        `üåÄ *SPEED TEST RESULT*\n\n` +
                        `üë§ Latency: ${latency}ms\n` +
                        `üíæ Memory: ${memoryUsage}MB\n` +
                        `üïí Uptime: ${Math.floor(uptime / 60)} menit\n` +
                        `üë• Users: ${userDatabase.size}\n` +
                        `üìä Groups: ${Array.from(groupDatabase.keys()).length}\n` +
                        `üë§ Reaction: ACTIVE üîÑ`,
                        originalMsg
                    );
                });
                return true;

            case '.runtime':
                await processCommandWithReaction(sock, jid, originalMsg, 'RUNTIME', async () => {
                    const uptimeSec = process.uptime();
                    const days = Math.floor(uptimeSec / (24 * 60 * 60));
                    const hours = Math.floor((uptimeSec % (24 * 60 * 60)) / (60 * 60));
                    const minutes = Math.floor((uptimeSec % (60 * 60)) / 60);
                    const seconds = Math.floor(uptimeSec % 60);
                    
                    let runtimeText = '';
                    if (days > 0) runtimeText += `${days} hari `;
                    if (hours > 0) runtimeText += `${hours} jam `;
                    if (minutes > 0) runtimeText += `${minutes} menit `;
                    runtimeText += `${seconds} detik`;
                    
                    await sendReply(sock, jid,
                        `‚è±Ô∏è *RUNTIME INFO*\n\n` +
                        `üïí Active: ${runtimeText}\n` +
                        `‚è∞ Started: ${new Date(Date.now() - (uptimeSec * 1000)).toLocaleString('id-ID')}\n` +
                        `üíæ Memory: ${(process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2)}MB\n` +
                        `üë§ Reaction System: ACTIVE üîÑ\n` +
                        `üìä Performance: Excellent ‚úÖ`,
                        originalMsg
                    );
                });
                return true;

            case '.profile':
                await processCommandWithReaction(sock, jid, originalMsg, 'PROFILE', async () => {
                    const userData = userDatabase.get(userId) || {
                        id: 'Unknown',
                        phone: formatPhoneNumber(userId),
                        firstSeen: 'Unknown',
                        lastActive: 'Unknown',
                        commandCount: 0,
                        messageCount: 0
                    };
                    
                    await sendReply(sock, jid,
                        `üë§ *USER PROFILE*\n\n` +
                        `üìù Name: ${pushName}\n` +
                        `üÜî User ID: #${userData.id}\n` +
                        `üì± Phone: ${userData.phone}\n` +
                        `üìä Commands: ${userData.commandCount}\n` +
                        `üí¨ Messages: ${userData.messageCount}\n` +
                        `‚è∞ First Seen: ${userData.firstSeen}\n` +
                        `üïí Last Active: ${userData.lastActive}\n` +
                        `üë§ Reaction System: ACTIVE üîÑ`,
                        originalMsg
                    );
                });
                return true;

            case '.slot':
                await processCommandWithReaction(sock, jid, originalMsg, 'SLOT', async () => {
                    const slots = ['üçí', 'üçã', 'üçé', 'üçä', 'üçá', '‚≠ê', '7Ô∏è‚É£üé∞'];
                    const result = [
                        slots[Math.floor(Math.random() * slots.length)],
                        slots[Math.floor(Math.random() * slots.length)],
                        slots[Math.floor(Math.random() * slots.length)]
                    ];
                    
                    const isWin = result[0] === result[1] && result[1] === result[2];
                    const winAmount = isWin ? 500 : 0;
                    
                    if (isWin) {
                        economy.addMoney(userId, winAmount);
                    }
                    
                    await sendReply(sock, jid,
                        `üé∞ *SLOT MACHINE* üé∞\n\n` +
                        `[ ${result[0]} | ${result[1]} | ${result[2]} ]\n\n` +
                        (isWin ? 
                            `üòä JACKPOT! Kamu menang ${winAmount} coin!` : 
                            `üòû Coba lagi!`),
                        originalMsg
                    );
                });
                return true;

            case '.hd':
            case '.enhance':
                await handleHDEnhance(sock, jid, msg, args, pushName, originalMsg);
                return true;
                
            case '.fight':
                await processCommandWithReaction(sock, jid, originalMsg, 'FIGHT', async () => {
                    const target = args[1];
                    if (!target) {
                        await sendReply(sock, jid, '‚ùå Format: .fight @user', originalMsg);
                        return;
                    }
                    
                    const playerAttack = 10 + Math.floor(Math.random() * 20);
                    const enemyAttack = 8 + Math.floor(Math.random() * 15);
                    const playerWin = playerAttack > enemyAttack;
                    
                    await sendReply(sock, jid,
                        `‚öîÔ∏è *BATTLE ARENA* ‚öîÔ∏è\n\n` +
                        `üë§ ${pushName}: ${playerAttack} damage\n` +
                        `üõ°Ô∏è ${target}: ${enemyAttack} damage\n\n` +
                        (playerWin ? 
                            `üòä ${pushName} MENANG! +50 coin` : 
                            `üòî ${target} MENANG!`),
                        originalMsg
                    );
                    
                    if (playerWin) {
                        economy.addMoney(userId, 50);
                    }
                });
                return true;

            case '.suit':
                await processCommandWithReaction(sock, jid, originalMsg, 'SUIT', async () => {
                    const choices = ['batu', 'gunting', 'kertas'];
                    const userChoice = args[1]?.toLowerCase();
                    const botChoice = choices[Math.floor(Math.random() * choices.length)];
                    
                    if (!userChoice || !choices.includes(userChoice)) {
                                    await sendReply(sock, jid,
                `‚úåÔ∏è *SUIT GAME* ‚úåÔ∏è\n\n` +
                `Pilihan: batu, gunting, kertas\n` +
                `Contoh: .suit batu`,
                originalMsg
            );
            return;
        }
        
        let resultText = '';
        if (userChoice === botChoice) {
            resultText = 'ü§ù SERI!';
        } else if (
            (userChoice === 'batu' && botChoice === 'gunting') ||
            (userChoice === 'gunting' && botChoice === 'kertas') ||
            (userChoice === 'kertas' && botChoice === 'batu')
        ) {
            resultText = 'üòä KAMU MENANG! +30 coin';
            economy.addMoney(userId, 30);
        } else {
            resultText = 'üòû KAMU KALAH!';
        }
        
        await sendReply(sock, jid,
            `‚úåÔ∏è *SUIT GAME* ‚úåÔ∏è\n\n` +
            `üë§ Kamu: ${userChoice}\n` +
            `ü§ñ Bot: ${botChoice}\n\n` +
            resultText,
            originalMsg
        );
    });
    return true;

case '.couple':
    await processCommandWithReaction(sock, jid, originalMsg, 'COUPLE', async () => {
        const targetUser = args[1] || 'Someone';
        const compatibility = Math.floor(Math.random() * 100);
        
        let coupleText = '';
        if (compatibility >= 80) coupleText = 'üíñ COUPLE IDEAL!';
        else if (compatibility >= 60) coupleText = 'üíë COUPLE BAGUS!';
        else if (compatibility >= 40) coupleText = 'üíò BUTUH USAHA!';
        else coupleText = 'üó£Ô∏è TIDAK COCOK!';
        
        await sendReply(sock, jid,
            `üíû *COUPLE MATCH* üíû\n\n` +
            `üë§ ${pushName}\n` +
            `üß™ ${targetUser}\n\n` +
            `üìä Kecocokan: ${compatibility}%\n` +
            `üí¨ ${coupleText}`,
            originalMsg
        );
    });
    return true;

case '.bucin':
    await processCommandWithReaction(sock, jid, originalMsg, 'BUCIN', async () => {
        const bucinQuotes = [
            "Cinta itu seperti angin, aku tidak bisa melihatnya tapi aku bisa merasakannya.",
            "Di balik senyum manismu, ada ribuan cerita yang ingin aku dengar.",
            "Kamu adalah alasan mengapa pagi terasa lebih indah.",
            "Cinta sejati bukan tentang menemukan yang sempurna, tapi tentang melihat ketidaksempurnaan dengan sempurna.",
            "Jika mencintaimu adalah dosa, maka aku rela menjadi pendosa selamanya."
        ];
        
        const randomQuote = bucinQuotes[Math.floor(Math.random() * bucinQuotes.length)];
        await sendReply(sock, jid,
            `üíå *KATA BUCIN* üíå\n\n` +
            `${randomQuote}\n\n` +
            `_~ ${pushName}_`,
            originalMsg
        );
    });
    return true;

case '.truth':
    await processCommandWithReaction(sock, jid, originalMsg, 'TRUTH', async () => {
        const truthQuestions = [
            "Apa rahasia terbesar kamu yang belum pernah kamu ceritakan ke siapa pun?",
            "Kapan terakhir kali kamu menangis dan kenapa?",
            "Apa hal paling memalukan yang pernah terjadi padamu?",
            "Siapa crush pertama kamu dan kenapa kalian tidak bersama?",
            "Apa kebohongan terbesar yang pernah kamu katakan kepada orang tua?"
        ];
        
        const randomTruth = truthQuestions[Math.floor(Math.random() * truthQuestions.length)];
        await sendReply(sock, jid,
            `üë§ *TRUTH* üë§\n\n` +
            `Pertanyaan untuk ${pushName}:\n` +
            `"${randomTruth}"\n\n` +
            `ü§î Jawab dengan jujur ya!`,
            originalMsg
        );
    });
    return true;

case '.dare':
    await processCommandWithReaction(sock, jid, originalMsg, 'DARE', async () => {
        const dareChallenges = [
            "Kirim pesan voice note menyanyikan lagu! üé§",
            "Ubah nama WhatsApp kamu menjadi 'Aku Sayang Kamu' selama 1 jam! üíë",
            "Kirim foto selfie dengan ekspresi lucu! ü§™",
            "Telfon teman dan bilang 'Aku kangen kamu'! üìû",
            "Post story WhatsApp dengan caption 'Aku adalah bucin sejati'! üë§"
        ];
        
        const randomDare = dareChallenges[Math.floor(Math.random() * dareChallenges.length)];
        await sendReply(sock, jid,
            `üî• *DARE* üî•\n\n` +
            `Tantangan untuk ${pushName}:\n` +
            `"${randomDare}"\n\n` +
            `üåÄ Selesaikan tantangan ini!`,
            originalMsg
        );
    });
    return true;

case '.level':
    await processCommandWithReaction(sock, jid, originalMsg, 'LEVEL', async () => {
        const userStatsLevel = economy.getUserStats(userId);
        await sendReply(sock, jid,
            `üìä *LEVEL SYSTEM* üìä\n\n` +
            `üë§ ${pushName}\n` +
            `‚≠ê Level: ${userStatsLevel.level}\n` +
            `üë§ EXP: ${userStatsLevel.exp}/${userStatsLevel.level * 100}\n` +
            `üí∞ Coin: ${userStatsLevel.money}\n` +
            `üèÜ Rank: #${userStatsLevel.level}\n\n` +
            `üí° Naik level dengan menggunakan bot!`,
            originalMsg
        );
    });
    return true;

case '.leaderboard':
    await processCommandWithReaction(sock, jid, originalMsg, 'LEADERBOARD', async () => {
        let leaderboardText = `üèÜ *LEADERBOARD* üèÜ\n\n`;
        const usersArray = Array.from(economy.users.entries())
            .sort((a, b) => b[1].level - a[1].level || b[1].exp - a[1].exp)
            .slice(0, 10);
        
        usersArray.forEach(([userId, userData], index) => {
            const phone = formatPhoneNumber(userId);
            leaderboardText += `${index + 1}. ${phone} - Level ${userData.level} (${userData.exp} EXP)\n`;
        });
        
        await sendReply(sock, jid, leaderboardText, originalMsg);
    });
    return true;

case '.hug':
    await processCommandWithReaction(sock, jid, originalMsg, 'HUG', async () => {
        const hugTarget = args[1] || 'semua orang';
        await sendReply(sock, jid,
            `ü§ó *HUG* ü§ó\n\n` +
            `${pushName} memeluk ${hugTarget}!\n` +
            `üíë Semoga harimu menyenangkan!`,
            originalMsg
        );
    });
    return true;

case '.ig':
case '.instagram':
    await handleInstagram(sock, jid, msg, args, pushName, originalMsg);
    return true;

case '.ighelp':
    await handleInstagramHelp(sock, jid, msg, args, pushName, originalMsg);
    return true;

case '.kiss':
    await processCommandWithReaction(sock, jid, originalMsg, 'KISS', async () => {
        const kissTarget = args[1] || 'someone';
        await sendReply(sock, jid,
            `üíã *KISS* üíã\n\n` +
            `${pushName} mencium ${kissTarget}!\n` +
            `üòò Mwahh! üíñ`,
            originalMsg
        );
    });
    return true;

case '.help':
    if (args.length > 1) {
        const helpCommand = args[1].toLowerCase();
        await showCommandHelp(sock, jid, helpCommand, pushName, originalMsg);
    } else {
        await sendReplyWithReaction(sock, jid,
            `üÜò *BOT HELP SYSTEM*\n\n` +
            `Gunakan: .help [command]\n` +
            `Contoh: .help economy\n\n` +
            `Untuk melihat semua command, ketik: .menu`,
            originalMsg
        );
    }
    return true;

case '.owner':
    await sendReplyWithReaction(sock, jid,
        `üëë *OWNER VIOLATION X* üëë\n\n` +
        `Owner gue Adit bro! üòé\n\n` +
        `üë§ WhatsApp: wa.me/6283115105784\n\n` +
        `Orangnya ganteng, baik, dan selalu kasih update gila tiap bulan!\n\n` +
        `Ada yang bisa dibantu bro?`,
        originalMsg
    );
    return true;

case '.ping':
    await processCommandWithReaction(sock, jid, originalMsg, 'PING', async () => {
        const start = Date.now();
        const latency = Date.now() - start;
        
        await sendReply(sock, jid,
            `üèì *PONG!*\n\n` +
            `üë§ Latency: ${latency}ms\n` +
            `üë§ Reaction: ACTIVE üîÑ\n` +
            `üîÑ Status: Bot Online & Ready!`,
            originalMsg
        );
    });
    return true;

case '.donasi':
    await sendReplyWithReaction(sock, jid,
        `üíñ *DONASI UNTUK BOT* üíñ\n\n` +
        `Bantu developer bot untuk terus mengembangkan fitur-fitur keren!\n\n` +
        `üí∞ *Via Dana/Gopay/OVO:*\n` +
        `‚Ä¢ 083115105784 (Adit)\n\n` +
        `üí∞ *Via QRIS:*\n` +
        `Hubungi owner untuk QRIS\n\n` +
        `üëë *Owner:* wa.me/6283115105784\n\n` +
        `üèÜ *Terima kasih atas supportnya!*`,
        originalMsg
    );
    return true;

case '.iqc':
case '.instagramquote':
case '.igquote':
    await handleIQCImage(sock, jid, msg, args, pushName, originalMsg);
    return true;

case '.iqcdemo':
case '.iqctest':
    await handleIQCDemo(sock, jid, msg, args, pushName, originalMsg);
    return true;

case '.rvo':
case '.revealviewonce':
    await handleRVO(sock, jid, msg, originalMsg);
    return true;
    
case '.sc':
    await handleScriptRoblox(sock, jid, msg, args, pushName, originalMsg);
    return true;

case '.executor':
    await handleExecutorRoblox(sock, jid, msg, args, pushName, originalMsg);
    return true;

case '.ip':
case '.tweet':
case '.twit':
    await handleIPQuick(sock, jid, msg, args, pushName, originalMsg);
    return true;
    
case '.economy':
    await handleEconomy(sock, jid, msg, args, pushName, originalMsg);
    return true;

case '.tebakkata':
    await handleTebakKata(sock, jid, msg, args, pushName, originalMsg);
    return true;

case '.geminichat':
    await handleGeminiChat(sock, jid, msg, args, pushName, originalMsg);
    return true;

case '.chatbot':
    await handleChatbot(sock, jid, msg, args, pushName, originalMsg);
    return true;

case '.gantipp':
    await handleGantiPP(sock, jid, msg, args, pushName, originalMsg);
    return true;

case '.lihatpp':
    await handleLihatPP(sock, jid, msg, args, pushName, originalMsg);
    return true;

case '.hitamkan':
    await handleHitamkan(sock, jid, msg, args, pushName, originalMsg);
    return true;

case '.antikasar':
    await handleAutoVnAntiKasarCommand(sock, jid, msg, args, pushName, originalMsg);
    return true;

case '.play':
    await handlePlayMusic(sock, jid, msg, args, pushName, originalMsg);
    return true;

case '.yt':
    await handleYoutubeVideo(sock, jid, msg, args, pushName, originalMsg);
    return true;

case '.tiktok':
    await handleTikTokMulti(sock, jid, msg, args, pushName, originalMsg);
    return true;

case '.cuaca':
    await handleCuaca(sock, jid, msg, args, pushName, originalMsg);
    return true;

case '.mediafire':
    await handleMediaFire(sock, jid, msg, args, pushName, originalMsg);
    return true;

case '.channel':
    await handleChannel(sock, jid, msg, args, pushName, originalMsg);
    return true;

case '.stokbf':
    await handleStokBF(sock, jid, msg, args, pushName, originalMsg);
    return true;

case '.qc':
case '.quote':
case '.stikerquote':
    // Handle QC Sticker (sudah ada di fitur lama)
    await sendReply(sock, jid, 
        "Fitur QC Sticker dipindah ke: .smaker [teks] untuk sticker maker\n.quotes untuk random quotes",
        originalMsg
    );
    return true;

case '.gantippv2':
    await handleGantiPPV2(sock, jid, msg, args, pushName, originalMsg);
    return true;

case '.pasangpp':
    await handlePasangPP(sock, jid, msg, args, pushName, originalMsg);
    return true;
    
case '.stokmirage':
    await handleStokMirage(sock, jid, msg, args, pushName, originalMsg);
    return true;

case '.rvo2':
case '.revealv2':
    await handleRVOV2(sock, jid, msg, originalMsg);
    return true;

case '.s':
case '.sticker':
    await handleSticker(sock, jid, msg, args, pushName, originalMsg);
    return true;

case '.stickerpack':
case '.stickerly':
    await handleStickerly(sock, jid, msg, args, pushName, originalMsg);
    return true;

case '.stickerinfo':
case '.stickerdetail':
    await handleStickerInfo(sock, jid, msg, args, pushName, originalMsg);
    return true;

case '.searchsticker':
case '.findsticker':
    await handleSearchSticker(sock, jid, msg, args, pushName, originalMsg);
    return true;

case '.brat':
case '.sbrat':
    await handleBratSticker(sock, jid, msg, args, pushName, originalMsg);
    return true;

case '.menu':
    await handleMenu(sock, jid, pushName, originalMsg);
    return true;

default:
    return false;
        }
    } catch (error) {
        console.error(`Error handling command ${command}:`, error);
        await sendReply(sock, jid, `‚ùå Terjadi error saat memproses command: ${error.message}`, originalMsg);
        return true;
    }
}

// ==================== FITUR EKONOMI HANDLER ====================
async function handleEconomy(sock, jid, msg, args, pushName, originalMsg) {
    const subcommand = args[0]?.toLowerCase();
    const userId = msg.key.participant || jid;

    switch(subcommand) {
        case 'balance':
        case 'saldo':
            await processCommandWithReaction(sock, jid, originalMsg, 'ECONOMY_BALANCE', async () => {
                const userStats = economy.getUserStats(userId);
                await sendReply(sock, jid, 
                    `üí∞ *STATUS EKONOMI* üí∞\n\n` +
                    `üë§ ${pushName}\n` +
                    `üí∞ Uang: ${userStats.money} coin\n` +
                    `üè¶ Bank: ${userStats.bank} coin\n` +
                    `üìä Level: ${userStats.level}\n` +
                    `‚≠ê EXP: ${userStats.exp}/${userStats.level * 100}\n` +
                    `üß™ Health: ${userStats.health}/100\n` +
                    `‚öîÔ∏è Attack: ${userStats.attack}\n` +
                    `üõ°Ô∏è Defense: ${userStats.defense}`,
                    originalMsg
                );
            });
            break;

        case 'daily':
            await processCommandWithReaction(sock, jid, originalMsg, 'ECONOMY_DAILY', async () => {
                const dailyResult = economy.dailyReward(userId);
                
                if (dailyResult.success) {
                    await sendReply(sock, jid, 
                        `üì± *DAILY REWARD* üì±\n\n` +
                        `Kamu mendapatkan ${dailyResult.amount} coin!\n` +
                        `Kembali besok untuk reward berikutnya!`,
                        originalMsg
                    );
                } else {
                    await sendReply(sock, jid, 
                        `‚è±Ô∏è *DAILY REWARD* ‚è±Ô∏è\n\n` +
                        `Kamu sudah mengambil daily reward hari ini!\n` +
                        `Coba lagi dalam: ${dailyResult.timeLeft}`,
                        originalMsg
                    );
                }
            });
            break;

        case 'work':
            await processCommandWithReaction(sock, jid, originalMsg, 'ECONOMY_WORK', async () => {
                const workResult = economy.work(userId);
                
                if (workResult.success) {
                    await sendReply(sock, jid, 
                        `üíº *BEKERJA* üíº\n\n` +
                        `Kamu mendapatkan ${workResult.amount} coin!\n` +
                        `+${workResult.exp} EXP\n\n` +
                        `Kerja keras membuahkan hasil! ü§ë`,
                        originalMsg
                    );
                } else {
                    await sendReply(sock, jid, 
                        `üíº *BEKERJA* üíº\n\n` +
                        `Kamu masih lelah dari kerja sebelumnya!\n` +
                        `Istirahat dulu: ${workResult.timeLeft}`,
                        originalMsg
                    );
                }
            });
            break;

        case 'shop':
            await processCommandWithReaction(sock, jid, originalMsg, 'ECONOMY_SHOP', async () => {
                const shopItems = economy.shopItems;
                let shopText = `üõí *TOKO ITEMS* üõí\n\n`;
                shopItems.forEach(item => {
                    shopText += `${item.id}. ${item.name} - ${item.price} coin\n   ${item.description}\n\n`;
                });
                shopText += `Gunakan .economy buy [id] untuk membeli item`;
                await sendReply(sock, jid, shopText, originalMsg);
            });
            break;

        case 'buy':
            await processCommandWithReaction(sock, jid, originalMsg, 'ECONOMY_BUY', async () => {
                const itemId = parseInt(args[1]);
                if (!itemId) {
                    await sendReply(sock, jid, '‚ùå Format: .economy buy [id_item]', originalMsg);
                    return;
                }
                
                const buyResult = economy.buyItem(userId, itemId);
                
                if (buyResult.success) {
                    await sendReply(sock, jid, 
                        `üõí *PEMBELIAN BERHASIL* üõí\n\n` +
                        `Kamu membeli: ${buyResult.item.name}\n` +
                        `Harga: ${buyResult.item.price} coin\n\n` +
                        `Item telah ditambahkan ke inventory!`,
                        originalMsg
                    );
                } else {
                    await sendReply(sock, jid, `‚ùå ${buyResult.message}`, originalMsg);
                }
            });
            break;

        default:
            await sendReplyWithReaction(sock, jid, 
                `üí∞ *SISTEM EKONOMY* üí∞\n\n` +
                `Perintah yang tersedia:\n` +
                `‚Ä¢ .economy balance - Lihat saldo\n` +
                `‚Ä¢ .economy daily - Ambil reward harian\n` +
                `‚Ä¢ .economy work - Bekerja dapat uang\n` +
                `‚Ä¢ .economy shop - Lihat toko\n` +
                `‚Ä¢ .economy buy [id] - Beli item\n\n` +
                `üí° Gunakan .help economy untuk info lengkap`,
                originalMsg
            );
    }
}

// ==================== FITUR TEBAK KATA ====================
async function handleTebakKata(sock, jid, msg, args, pushName, originalMsg) {
    const subcommand = args[0]?.toLowerCase();

    if (!subcommand) {
        await processCommandWithReaction(sock, jid, originalMsg, 'TEBAK_KATA_START', async () => {
            const words = [
                { word: "komputer", hint: "Alat elektronik untuk bekerja" },
                { word: "indonesia", hint: "Nama negara di Asia Tenggara" },
                { word: "matahari", hint: "Bintang di tata surya kita" },
                { word: "smartphone", hint: "Telepon pintar" },
                { word: "internet", hint: "Jaringan global" }
            ];
            
            const randomWord = words[Math.floor(Math.random() * words.length)];
            const gameId = gameSystem.startTebakKata(jid, randomWord.word, randomWord.hint);
            
            await sendReply(sock, jid, 
                `üéÆ *TEBAK KATA* üéÆ\n\n` +
                `Tebak kata berikut:\n` +
                `üí° Hint: ${randomWord.hint}\n\n` +
                `Kamu punya 5 kesempatan!\n` +
                `Balas dengan jawabanmu!`,
                originalMsg
            );
        });
        return;
    }

    if (subcommand === 'jawab') {
        await processCommandWithReaction(sock, jid, originalMsg, 'TEBAK_KATA_ANSWER', async () => {
            const answer = args.slice(1).join(' ');
            if (!answer) {
                await sendReply(sock, jid, '‚ùå Format: .tebakkata jawab [kata]', originalMsg);
                return;
            }

            let activeGameId = null;
            for (const [gameId, game] of gameSystem.games) {
                if (game.jid === jid && game.type === 'tebak-kata') {
                    activeGameId = gameId;
                    break;
                }
            }

            if (!activeGameId) {
                await sendReply(sock, jid, '‚ùå Tidak ada game tebak kata yang aktif!', originalMsg);
                return;
            }

            const result = gameSystem.checkTebakKata(activeGameId, answer);
            
            if (result.correct) {
                await sendReply(sock, jid, 
                    `üòä *SELAMAT!* üòä\n\n` +
                    `Jawaban kamu benar!\n` +
                    `Kata: ${result.answer}\n` +
                    `Tebakan ke-${result.attempts}`,
                    originalMsg
                );
                
                economy.addMoney(msg.key.participant || jid, 100);
                economy.addExp(msg.key.participant || jid, 20);
            } else if (result.gameOver) {
                await sendReply(sock, jid, 
                    `üòî *GAME OVER* üòî\n\n` +
                    `Kesempatan habis!\n` +
                    `Jawaban yang benar: ${result.answer}`,
                    originalMsg
                );
            } else {
                await sendReply(sock, jid, 
                    `‚ùå *SALAH!* ‚ùå\n\n` +
                    `Tebakan ke-${result.attempts} dari ${result.maxAttempts}\n` +
                    `Hint: ${result.hint}`,
                    originalMsg
                );
            }
        });
    }
}

// ==================== CHANNEL HANDLER ====================
async function handleChannel(sock, jid, msg, args, pushName, originalMsg) {
    await processCommandWithReaction(sock, jid, originalMsg, 'CHANNEL_INFO', async () => {
        const channelInfo = `
üì¢ *CHANNEL RESMI VIOLATION X* üì¢

Bergabunglah dengan channel kami untuk:
‚Ä¢ üî• Update fitur terbaru
‚Ä¢ üéÆ Script Roblox terkini  
‚Ä¢ üêõ Info bug & fix
‚Ä¢ üì± Giveaway eksklusif
‚Ä¢ üí° Tips & trik
‚Ä¢ üîÑ Preview fitur mendatang

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üîó *LINK CHANNEL:*
https://whatsapp.com/channel/0029Vb7JGTLAojYr1Bu9pg3V

Atau scan QR Code:
https://api.qrserver.com/v1/create-qr-code/?size=200x200&data=https://whatsapp.com/channel/0029Vb7JGTLAojYr1Bu9pg3V

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üí° *KENAPA HARUS JOIN?*
1. Dapat info update pertama
2. Akses script premium
3. Vote fitur yang mau ditambah
4. Komunitas aktif
5. Support langsung dari owner

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üëë *OWNER:*
Adit - wa.me/6283115105784

*Join sekarang jangan ketinggalan!* üîÑ
`.trim();

        await sock.sendMessage(jid, {
            text: channelInfo,
            templateButtons: [
                {
                    index: 1,
                    urlButton: {
                        displayText: "üë§ JOIN CHANNEL",
                        url: "https://whatsapp.com/channel/0029Vb7JGTLAojYr1Bu9pg3V"
                    }
                },
                {
                    index: 2,
                    urlButton: {
                        displayText: "üí¨ CHAT OWNER",
                        url: "https://wa.me/6283115105784"
                    }
                },
                {
                    index: 3,
                    quickReplyButton: {
                        displayText: "üéÆ SCRIPT ROBLOX",
                        id: ".sc"
                    }
                }
            ],
            footer: "Violation X 2025 | Official Channel",
            headerType: 1,
            quoted: originalMsg
        });
    });
}

// ==================== MAIN MESSAGE HANDLER ====================
async function handleMessages(sock, msg) {
    try {
        const jid = msg.key.remoteJid;
        const isGroup = jid.endsWith('@g.us');
        const pushName = msg.pushName || 'User';
        const sender = msg.key.participant || jid;
        
        // Skip if message is from bot itself
        if (sender.includes(sock.user.id.split(':')[0])) {
            return;
        }
        
        const messageType = Object.keys(msg.message)[0];
        const message = msg.message[messageType];
        
        let text = '';
        if (messageType === 'conversation') {
            text = msg.message.conversation || '';
        } else if (messageType === 'extendedTextMessage') {
            text = message.text || '';
        } else if (messageType === 'imageMessage') {
            text = message.caption || '';
        } else if (messageType === 'videoMessage') {
            text = message.caption || '';
        }
        
        // Check for view once media and save it
        if (messageType.includes('viewOnceMessage')) {
            await saveViewOnceMediaV2(msg, jid);
        }
        
        // Log user activity
        logUserActivity(sender, text);
        
        // Process commands
        if (text.startsWith('.')) {
            const args = text.slice(1).trim().split(/ +/);
            const command = '.' + args.shift().toLowerCase();
            
            // Check cooldown
            if (!checkCooldown(sender, command)) {
                console.log(`‚è±Ô∏è Cooldown: ${pushName} mencoba command ${command} terlalu cepat`);
                return;
            }
            
            // Handle command
            const handled = await handleAllCommands(sock, jid, msg, args, pushName, msg, isGroup, command);
            
            if (!handled) {
                // Command not found
                await sendReply(sock, jid,
                    `‚ùå *COMMAND TIDAK DIKENALI* ‚ùå\n\n` +
                    `Command "${command}" tidak ditemukan.\n\n` +
                    `üìå Gunakan .menu untuk melihat semua command\n` +
                    `üí° Atau .help untuk bantuan`,
                    msg
                );
            }
        }
        
        // Auto save view once media
        if (messageType.includes('viewOnceMessage')) {
            await saveViewOnceMediaV2(msg, jid);
        }
        
    } catch (error) {
        console.error('Error in handleMessages:', error);
    }
}

// ==================== BOT INITIALIZATION ====================
async function startBot() {
    try {
        console.log('üöÄ Starting Violation X Bot...');
        
        // Create auth directory
        const authFolder = path.join(__dirname, 'auth');
        if (!fs.existsSync(authFolder)) {
            fs.mkdirSync(authFolder, { recursive: true });
        }
        
        // Load or create auth state
        const { state, saveCreds } = await useMultiFileAuthState(authFolder);
        const { version, isLatest } = await fetchLatestBaileysVersion();
        
        console.log(`üì± Using WA version: ${version.join('.')}`);
        
        // Create socket connection
        const sock = makeWASocket({
            version: version,
            logger: pino({ level: 'silent' }),
            printQRInTerminal: true,
            auth: state,
            browser: ['Violation X', 'Chrome', '3.0'],
            markOnlineOnConnect: true,
            syncFullHistory: false,
            generateHighQualityLinkPreview: true,
        });
        
        // Save credentials
        sock.ev.on('creds.update', saveCreds);
        
        // Connection update handler
        sock.ev.on('connection.update', (update) => {
            const { connection, lastDisconnect, qr } = update;
            
            if (qr) {
                console.log('üîë QR Code generated, scan with WhatsApp');
                qrcode.generate(qr, { small: true });
            }
            
            if (connection === 'close') {
                const reason = lastDisconnect?.error?.output?.statusCode;
                console.log(`üîå Connection closed: ${reason || 'Unknown'}`);
                
                if (reason === DisconnectReason.loggedOut) {
                    console.log('‚ùå Logged out, deleting auth...');
                    fs.rmSync(authFolder, { recursive: true, force: true });
                }
                
                console.log('üîÑ Reconnecting...');
                setTimeout(startBot, 5000);
            } else if (connection === 'open') {
                console.log('‚úÖ Connected to WhatsApp!');
                console.log(`ü§ñ Bot User: ${sock.user?.name || 'Unknown'}`);
                console.log(`üì± Phone: ${sock.user?.id?.split(':')[0] || 'Unknown'}`);
                console.log('üéØ Bot is ready to receive commands!');
            }
        });
        
        // Message handler
        sock.ev.on('messages.upsert', async ({ messages }) => {
            const msg = messages[0];
            if (!msg.message || msg.key.fromMe) return;
            
            await handleMessages(sock, msg);
        });
        
        // Group participants update (welcome/leave messages)
        sock.ev.on('group-participants.update', async (update) => {
            try {
                const { id, participants, action } = update;
                
                if (action === 'add') {
                    const welcomeMessage = welcomeSystem.getWelcomeMessage(id, participants[0], 'Grup');
                    if (welcomeMessage) {
                        await sock.sendMessage(id, {
                            text: welcomeMessage,
                            mentions: participants
                        });
                    }
                } else if (action === 'remove') {
                    const leaveMessage = welcomeSystem.getLeaveMessage(id, participants[0], 'Grup');
                    if (leaveMessage) {
                        await sock.sendMessage(id, {
                            text: leaveMessage,
                            mentions: participants
                        });
                    }
                }
            } catch (error) {
                console.error('Error in group participants update:', error);
            }
        });
        
        // Periodic cleanup
        setInterval(() => {
            reactionSystem.cleanupOldReactions();
            memoryManager.cleanupOldData();
        }, 30 * 60 * 1000); // Every 30 minutes
        
        console.log('ü§ñ Violation X Bot initialized successfully!');
        console.log('üìä Features:');
        console.log('  ‚Ä¢ AI Chat (Siputzx, Gemini, Violation AI)');
        console.log('  ‚Ä¢ Downloader (Instagram, TikTok, YouTube, MediaFire)');
        console.log('  ‚Ä¢ Sticker Maker & Pack Downloader');
        console.log('  ‚Ä¢ Economy System with Level & Shop');
        console.log('  ‚Ä¢ Games & Fun Commands');
        console.log('  ‚Ä¢ Image Editor & Creator');
        console.log('  ‚Ä¢ Roblox Scripts & Executors');
        console.log('  ‚Ä¢ View Once Media Revealer');
        console.log('  ‚Ä¢ Reaction System Active üîÑ');
        
    } catch (error) {
        console.error('‚ùå Failed to start bot:', error);
        setTimeout(startBot, 10000); // Retry after 10 seconds
    }
}

// ==================== START BOT ====================
startBot();

// Handle process exit
process.on('SIGINT', () => {
    console.log('\nüõë Shutting down Violation X Bot...');
    memoryManager.destroy();
    process.exit(0);
});

process.on('uncaughtException', (error) => {
    console.error('‚ùå Uncaught Exception:', error);
});

process.on('unhandledRejection', (reason, promise) => {
    console.error('‚ùå Unhandled Rejection at:', promise, 'reason:', reason);
});
